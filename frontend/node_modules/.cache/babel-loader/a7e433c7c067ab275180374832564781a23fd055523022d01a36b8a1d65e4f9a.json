{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst {\n  EvaluateResultType,\n  EvaluateResultSuccess,\n  EvaluateResultException,\n  ExceptionDetails\n} = require('./evaluateResult');\nconst {\n  Message\n} = require('./scriptTypes');\nconst {\n  RealmInfo,\n  RealmType,\n  WindowRealmInfo\n} = require('./realmInfo');\nconst {\n  RemoteValue\n} = require('./protocolValue');\nconst {\n  Source\n} = require('./scriptTypes');\nconst {\n  WebDriverError\n} = require('../lib/error');\nconst ScriptEvent = {\n  MESSAGE: 'script.message',\n  REALM_CREATED: 'script.realmCreated',\n  REALM_DESTROYED: 'script.realmDestroyed'\n};\n\n/**\n * Represents class to run events and commands of Script module.\n * Described in https://w3c.github.io/webdriver-bidi/#module-script.\n * @class\n */\nclass ScriptManager {\n  #callbackId = 0;\n  #listener;\n  constructor(driver) {\n    this._driver = driver;\n    this.#listener = new Map();\n    this.#listener.set(ScriptEvent.MESSAGE, new Map());\n    this.#listener.set(ScriptEvent.REALM_CREATED, new Map());\n    this.#listener.set(ScriptEvent.REALM_DESTROYED, new Map());\n  }\n  addCallback(eventType, callback) {\n    const id = ++this.#callbackId;\n    const eventCallbackMap = this.#listener.get(eventType);\n    eventCallbackMap.set(id, callback);\n    return id;\n  }\n  removeCallback(id) {\n    let hasId = false;\n    for (const [, callbacks] of this.#listener) {\n      if (callbacks.has(id)) {\n        callbacks.delete(id);\n        hasId = true;\n      }\n    }\n    if (!hasId) {\n      throw Error(`Callback with id ${id} not found`);\n    }\n  }\n  invokeCallbacks(eventType, data) {\n    const callbacks = this.#listener.get(eventType);\n    if (callbacks) {\n      for (const [, callback] of callbacks) {\n        callback(data);\n      }\n    }\n  }\n  async init(browsingContextIds) {\n    if (!(await this._driver.getCapabilities()).get('webSocketUrl')) {\n      throw Error('WebDriver instance must support BiDi protocol');\n    }\n    this.bidi = await this._driver.getBidi();\n    this._browsingContextIds = browsingContextIds;\n  }\n\n  /**\n   * Disowns the handles in the specified realm.\n   *\n   * @param {string} realmId - The ID of the realm.\n   * @param {string[]} handles - The handles to disown to allow garbage collection.\n   * @returns {Promise<void>} - A promise that resolves when the command is sent.\n   */\n  async disownRealmScript(realmId, handles) {\n    const params = {\n      method: 'script.disown',\n      params: {\n        handles: handles,\n        target: {\n          realm: realmId\n        }\n      }\n    };\n    await this.bidi.send(params);\n  }\n\n  /**\n   * Disowns the handles in the specified browsing context.\n   * @param {string} browsingContextId - The ID of the browsing context.\n   * @param {string[]} handles - The handles to disown to allow garbage collection.\n   * @param {String|null} [sandbox=null] - The sandbox name.\n   * @returns {Promise<void>} - A promise that resolves when the command is sent.\n   */\n  async disownBrowsingContextScript(browsingContextId, handles, sandbox = null) {\n    const params = {\n      method: 'script.disown',\n      params: {\n        handles: handles,\n        target: {\n          context: browsingContextId\n        }\n      }\n    };\n    if (sandbox != null) {\n      params.params.target['sandbox'] = sandbox;\n    }\n    await this.bidi.send(params);\n  }\n\n  /**\n   * Calls a function in the specified realm.\n   *\n   * @param {string} realmId - The ID of the realm.\n   * @param {string} functionDeclaration - The function to call.\n   * @param {boolean} awaitPromise - Whether to await the promise returned by the function.\n   * @param {LocalValue[]} [argumentValueList|null] - The list of argument values to pass to the function.\n   * @param {Object} [thisParameter|null] - The value of 'this' parameter for the function.\n   * @param {ResultOwnership} [resultOwnership|null] - The ownership of the result.\n   * @returns {Promise<EvaluateResultSuccess|EvaluateResultException>} - A promise that resolves to the evaluation result or exception.\n   */\n  async callFunctionInRealm(realmId, functionDeclaration, awaitPromise, argumentValueList = null, thisParameter = null, resultOwnership = null) {\n    const params = this.getCallFunctionParams('realm', realmId, null, functionDeclaration, awaitPromise, argumentValueList, thisParameter, resultOwnership);\n    const command = {\n      method: 'script.callFunction',\n      params\n    };\n    let response = await this.bidi.send(command);\n    return this.createEvaluateResult(response);\n  }\n\n  /**\n   * Calls a function in the specified browsing context.\n   *\n   * @param {string} realmId - The ID of the browsing context.\n   * @param {string} functionDeclaration - The function to call.\n   * @param {boolean} awaitPromise - Whether to await the promise returned by the function.\n   * @param {LocalValue[]} [argumentValueList|null] - The list of argument values to pass to the function.\n   * @param {Object} [thisParameter|null] - The value of 'this' parameter for the function.\n   * @param {ResultOwnership} [resultOwnership|null] - The ownership of the result.\n   * @returns {Promise<EvaluateResultSuccess|EvaluateResultException>} - A promise that resolves to the evaluation result or exception.\n   */\n  async callFunctionInBrowsingContext(browsingContextId, functionDeclaration, awaitPromise, argumentValueList = null, thisParameter = null, resultOwnership = null, sandbox = null) {\n    const params = this.getCallFunctionParams('contextTarget', browsingContextId, sandbox, functionDeclaration, awaitPromise, argumentValueList, thisParameter, resultOwnership);\n    const command = {\n      method: 'script.callFunction',\n      params\n    };\n    const response = await this.bidi.send(command);\n    return this.createEvaluateResult(response);\n  }\n\n  /**\n   * Evaluates a function in the specified realm.\n   *\n   * @param {string} realmId - The ID of the realm.\n   * @param {string} expression - The expression to function to evaluate.\n   * @param {boolean} awaitPromise - Whether to await the promise.\n   * @param {ResultOwnership|null} resultOwnership - The ownership of the result.\n   * @returns {Promise<EvaluateResultSuccess|EvaluateResultException>} - A promise that resolves to the evaluation result or exception.\n   */\n  async evaluateFunctionInRealm(realmId, expression, awaitPromise, resultOwnership = null) {\n    const params = this.getEvaluateParams('realm', realmId, null, expression, awaitPromise, resultOwnership);\n    const command = {\n      method: 'script.evaluate',\n      params\n    };\n    let response = await this.bidi.send(command);\n    return this.createEvaluateResult(response);\n  }\n\n  /**\n   * Evaluates a function in the browsing context.\n   *\n   * @param {string} realmId - The ID of the browsing context.\n   * @param {string} expression - The expression to function to evaluate.\n   * @param {boolean} awaitPromise - Whether to await the promise.\n   * @param {ResultOwnership|null} resultOwnership - The ownership of the result.\n   * @returns {Promise<EvaluateResultSuccess|EvaluateResultException>} - A promise that resolves to the evaluation result or exception.\n   */\n  async evaluateFunctionInBrowsingContext(browsingContextId, expression, awaitPromise, resultOwnership = null, sandbox = null) {\n    const params = this.getEvaluateParams('contextTarget', browsingContextId, sandbox, expression, awaitPromise, resultOwnership);\n    const command = {\n      method: 'script.evaluate',\n      params\n    };\n    let response = await this.bidi.send(command);\n    return this.createEvaluateResult(response);\n  }\n\n  /**\n   * Adds a preload script.\n   *\n   * @param {string} functionDeclaration - The declaration of the function to be added as a preload script.\n   * @param {LocalValue[]} [argumentValueList=[]] - The list of argument values to be passed to the preload script function.\n   * @param {string} [sandbox|null] - The sandbox object to be used for the preload script.\n   * @returns {Promise<number>} - A promise that resolves to the added preload script ID.\n   */\n  async addPreloadScript(functionDeclaration, argumentValueList = [], sandbox = null) {\n    const params = {\n      functionDeclaration: functionDeclaration,\n      arguments: argumentValueList\n    };\n    if (sandbox !== null) {\n      params.sandbox = sandbox;\n    }\n    if (Array.isArray(this._browsingContextIds) && this._browsingContextIds.length > 0) {\n      params.contexts = this._browsingContextIds;\n    }\n    if (typeof this._browsingContextIds === 'string') {\n      params.contexts = new Array(this._browsingContextIds);\n    }\n    if (argumentValueList != null) {\n      let argumentParams = [];\n      argumentValueList.forEach(argumentValue => {\n        argumentParams.push(argumentValue.asMap());\n      });\n      params['arguments'] = argumentParams;\n    }\n    const command = {\n      method: 'script.addPreloadScript',\n      params\n    };\n    let response = await this.bidi.send(command);\n    return response.result.script;\n  }\n\n  /**\n   * Removes a preload script.\n   *\n   * @param {string} script - The ID for the script to be removed.\n   * @returns {Promise<any>} - A promise that resolves with the result of the removal.\n   * @throws {WebDriverError} - If an error occurs during the removal process.\n   */\n  async removePreloadScript(script) {\n    const params = {\n      script: script\n    };\n    const command = {\n      method: 'script.removePreloadScript',\n      params\n    };\n    let response = await this.bidi.send(command);\n    if ('error' in response) {\n      throw new WebDriverError(response.error);\n    }\n    return response.result;\n  }\n  getCallFunctionParams(targetType, id, sandbox, functionDeclaration, awaitPromise, argumentValueList = null, thisParameter = null, resultOwnership = null) {\n    const params = {\n      functionDeclaration: functionDeclaration,\n      awaitPromise: awaitPromise\n    };\n    if (targetType === 'contextTarget') {\n      if (sandbox != null) {\n        params['target'] = {\n          context: id,\n          sandbox: sandbox\n        };\n      } else {\n        params['target'] = {\n          context: id\n        };\n      }\n    } else {\n      params['target'] = {\n        realm: id\n      };\n    }\n    if (argumentValueList != null) {\n      let argumentParams = [];\n      argumentValueList.forEach(argumentValue => {\n        argumentParams.push(argumentValue.asMap());\n      });\n      params['arguments'] = argumentParams;\n    }\n    if (thisParameter != null) {\n      params['this'] = thisParameter;\n    }\n    if (resultOwnership != null) {\n      params['resultOwnership'] = resultOwnership;\n    }\n    return params;\n  }\n  getEvaluateParams(targetType, id, sandbox, expression, awaitPromise, resultOwnership = null) {\n    const params = {\n      expression: expression,\n      awaitPromise: awaitPromise\n    };\n    if (targetType === 'contextTarget') {\n      if (sandbox != null) {\n        params['target'] = {\n          context: id,\n          sandbox: sandbox\n        };\n      } else {\n        params['target'] = {\n          context: id\n        };\n      }\n    } else {\n      params['target'] = {\n        realm: id\n      };\n    }\n    if (resultOwnership != null) {\n      params['resultOwnership'] = resultOwnership;\n    }\n    return params;\n  }\n  createEvaluateResult(response) {\n    const type = response.result.type;\n    const realmId = response.result.realm;\n    let evaluateResult;\n    if (type === EvaluateResultType.SUCCESS) {\n      const result = response.result.result;\n      evaluateResult = new EvaluateResultSuccess(realmId, new RemoteValue(result));\n    } else {\n      const exceptionDetails = response.result.exceptionDetails;\n      evaluateResult = new EvaluateResultException(realmId, new ExceptionDetails(exceptionDetails));\n    }\n    return evaluateResult;\n  }\n  realmInfoMapper(realms) {\n    const realmsList = [];\n    realms.forEach(realm => {\n      realmsList.push(RealmInfo.fromJson(realm));\n    });\n    return realmsList;\n  }\n\n  /**\n   * Retrieves all realms.\n   * @returns {Promise<RealmInfo[]>} - A promise that resolves to an array of RealmInfo objects.\n   */\n  async getAllRealms() {\n    const command = {\n      method: 'script.getRealms',\n      params: {}\n    };\n    let response = await this.bidi.send(command);\n    return this.realmInfoMapper(response.result.realms);\n  }\n\n  /**\n   * Retrieves the realms by type.\n   *\n   * @param {Type} type - The type of realms to retrieve.\n   * @returns {Promise<RealmInfo[]>} - A promise that resolves to an array of RealmInfo objects.\n   */\n  async getRealmsByType(type) {\n    const command = {\n      method: 'script.getRealms',\n      params: {\n        type: type\n      }\n    };\n    let response = await this.bidi.send(command);\n    return this.realmInfoMapper(response.result.realms);\n  }\n\n  /**\n   * Retrieves the realms in the specified browsing context.\n   *\n   * @param {string} browsingContext - The browsing context ID.\n   * @returns {Promise<RealmInfo[]>} - A promise that resolves to an array of RealmInfo objects.\n   */\n  async getRealmsInBrowsingContext(browsingContext) {\n    const command = {\n      method: 'script.getRealms',\n      params: {\n        context: browsingContext\n      }\n    };\n    let response = await this.bidi.send(command);\n    return this.realmInfoMapper(response.result.realms);\n  }\n\n  /**\n   * Retrieves the realms in a browsing context based on the specified type.\n   *\n   * @param {string} browsingContext - The browsing context ID.\n   * @param {string} type - The type of realms to retrieve.\n   * @returns {Promise<RealmInfo[]>} - A promise that resolves to an array of RealmInfo objects.\n   */\n  async getRealmsInBrowsingContextByType(browsingContext, type) {\n    const command = {\n      method: 'script.getRealms',\n      params: {\n        context: browsingContext,\n        type: type\n      }\n    };\n    let response = await this.bidi.send(command);\n    return this.realmInfoMapper(response.result.realms);\n  }\n\n  /**\n   * Subscribes to the 'script.message' event and handles the callback function when a message is received.\n   *\n   * @param {Function} callback - The callback function to be executed when a message is received.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async onMessage(callback) {\n    return await this.subscribeAndHandleEvent(ScriptEvent.MESSAGE, callback);\n  }\n\n  /**\n   * Subscribes to the 'script.realmCreated' event and handles it with the provided callback.\n   *\n   * @param {Function} callback - The callback function to handle the 'script.realmCreated' event.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async onRealmCreated(callback) {\n    return await this.subscribeAndHandleEvent(ScriptEvent.REALM_CREATED, callback);\n  }\n\n  /**\n   * Subscribes to the 'script.realmDestroyed' event and handles it with the provided callback function.\n   *\n   * @param {Function} callback - The callback function to be executed when the 'script.realmDestroyed' event occurs.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async onRealmDestroyed(callback) {\n    return await this.subscribeAndHandleEvent(ScriptEvent.REALM_DESTROYED, callback);\n  }\n  async subscribeAndHandleEvent(eventType, callback) {\n    if (this._browsingContextIds != null) {\n      await this.bidi.subscribe(eventType, this._browsingContextIds);\n    } else {\n      await this.bidi.subscribe(eventType);\n    }\n    let id = this.addCallback(eventType, callback);\n    this.ws = await this.bidi.socket;\n    this.ws.on('message', event => {\n      const {\n        params\n      } = JSON.parse(Buffer.from(event.toString()));\n      if (params) {\n        let response = null;\n        if ('channel' in params) {\n          response = new Message(params.channel, new RemoteValue(params.data), new Source(params.source));\n        } else if ('realm' in params) {\n          if (params.type === RealmType.WINDOW) {\n            response = new WindowRealmInfo(params.realm, params.origin, params.type, params.context, params.sandbox);\n          } else if (params.realm !== null && params.type !== null) {\n            response = new RealmInfo(params.realm, params.origin, params.type);\n          } else if (params.realm !== null) {\n            response = params.realm;\n          }\n        }\n        this.invokeCallbacks(eventType, response);\n      }\n    });\n    return id;\n  }\n  async close() {\n    if (this._browsingContextIds !== null && this._browsingContextIds !== undefined && this._browsingContextIds.length > 0) {\n      await this.bidi.unsubscribe('script.message', 'script.realmCreated', 'script.realmDestroyed', this._browsingContextIds);\n    } else {\n      await this.bidi.unsubscribe('script.message', 'script.realmCreated', 'script.realmDestroyed');\n    }\n  }\n}\nasync function getScriptManagerInstance(browsingContextId, driver) {\n  let instance = new ScriptManager(driver);\n  await instance.init(browsingContextId);\n  return instance;\n}\nmodule.exports = getScriptManagerInstance;","map":{"version":3,"names":["EvaluateResultType","EvaluateResultSuccess","EvaluateResultException","ExceptionDetails","require","Message","RealmInfo","RealmType","WindowRealmInfo","RemoteValue","Source","WebDriverError","ScriptEvent","MESSAGE","REALM_CREATED","REALM_DESTROYED","ScriptManager","callbackId","listener","constructor","driver","_driver","Map","set","addCallback","eventType","callback","id","eventCallbackMap","get","removeCallback","hasId","callbacks","has","delete","Error","invokeCallbacks","data","init","browsingContextIds","getCapabilities","bidi","getBidi","_browsingContextIds","disownRealmScript","realmId","handles","params","method","target","realm","send","disownBrowsingContextScript","browsingContextId","sandbox","context","callFunctionInRealm","functionDeclaration","awaitPromise","argumentValueList","thisParameter","resultOwnership","getCallFunctionParams","command","response","createEvaluateResult","callFunctionInBrowsingContext","evaluateFunctionInRealm","expression","getEvaluateParams","evaluateFunctionInBrowsingContext","addPreloadScript","arguments","Array","isArray","length","contexts","argumentParams","forEach","argumentValue","push","asMap","result","script","removePreloadScript","error","targetType","type","evaluateResult","SUCCESS","exceptionDetails","realmInfoMapper","realms","realmsList","fromJson","getAllRealms","getRealmsByType","getRealmsInBrowsingContext","browsingContext","getRealmsInBrowsingContextByType","onMessage","subscribeAndHandleEvent","onRealmCreated","onRealmDestroyed","subscribe","ws","socket","on","event","JSON","parse","Buffer","from","toString","channel","source","WINDOW","origin","close","undefined","unsubscribe","getScriptManagerInstance","instance","module","exports"],"sources":["C:/Users/rayan/Documents/GitHub/Project-Outils/node_modules/selenium-webdriver/bidi/scriptManager.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst {\n  EvaluateResultType,\n  EvaluateResultSuccess,\n  EvaluateResultException,\n  ExceptionDetails,\n} = require('./evaluateResult')\nconst { Message } = require('./scriptTypes')\nconst { RealmInfo, RealmType, WindowRealmInfo } = require('./realmInfo')\nconst { RemoteValue } = require('./protocolValue')\nconst { Source } = require('./scriptTypes')\nconst { WebDriverError } = require('../lib/error')\n\nconst ScriptEvent = {\n  MESSAGE: 'script.message',\n  REALM_CREATED: 'script.realmCreated',\n  REALM_DESTROYED: 'script.realmDestroyed',\n}\n\n/**\n * Represents class to run events and commands of Script module.\n * Described in https://w3c.github.io/webdriver-bidi/#module-script.\n * @class\n */\nclass ScriptManager {\n  #callbackId = 0\n  #listener\n\n  constructor(driver) {\n    this._driver = driver\n    this.#listener = new Map()\n    this.#listener.set(ScriptEvent.MESSAGE, new Map())\n    this.#listener.set(ScriptEvent.REALM_CREATED, new Map())\n    this.#listener.set(ScriptEvent.REALM_DESTROYED, new Map())\n  }\n\n  addCallback(eventType, callback) {\n    const id = ++this.#callbackId\n\n    const eventCallbackMap = this.#listener.get(eventType)\n    eventCallbackMap.set(id, callback)\n    return id\n  }\n\n  removeCallback(id) {\n    let hasId = false\n    for (const [, callbacks] of this.#listener) {\n      if (callbacks.has(id)) {\n        callbacks.delete(id)\n        hasId = true\n      }\n    }\n\n    if (!hasId) {\n      throw Error(`Callback with id ${id} not found`)\n    }\n  }\n\n  invokeCallbacks(eventType, data) {\n    const callbacks = this.#listener.get(eventType)\n    if (callbacks) {\n      for (const [, callback] of callbacks) {\n        callback(data)\n      }\n    }\n  }\n\n  async init(browsingContextIds) {\n    if (!(await this._driver.getCapabilities()).get('webSocketUrl')) {\n      throw Error('WebDriver instance must support BiDi protocol')\n    }\n\n    this.bidi = await this._driver.getBidi()\n    this._browsingContextIds = browsingContextIds\n  }\n\n  /**\n   * Disowns the handles in the specified realm.\n   *\n   * @param {string} realmId - The ID of the realm.\n   * @param {string[]} handles - The handles to disown to allow garbage collection.\n   * @returns {Promise<void>} - A promise that resolves when the command is sent.\n   */\n  async disownRealmScript(realmId, handles) {\n    const params = {\n      method: 'script.disown',\n      params: {\n        handles: handles,\n        target: {\n          realm: realmId,\n        },\n      },\n    }\n\n    await this.bidi.send(params)\n  }\n\n  /**\n   * Disowns the handles in the specified browsing context.\n   * @param {string} browsingContextId - The ID of the browsing context.\n   * @param {string[]} handles - The handles to disown to allow garbage collection.\n   * @param {String|null} [sandbox=null] - The sandbox name.\n   * @returns {Promise<void>} - A promise that resolves when the command is sent.\n   */\n  async disownBrowsingContextScript(browsingContextId, handles, sandbox = null) {\n    const params = {\n      method: 'script.disown',\n      params: {\n        handles: handles,\n        target: {\n          context: browsingContextId,\n        },\n      },\n    }\n\n    if (sandbox != null) {\n      params.params.target['sandbox'] = sandbox\n    }\n\n    await this.bidi.send(params)\n  }\n\n  /**\n   * Calls a function in the specified realm.\n   *\n   * @param {string} realmId - The ID of the realm.\n   * @param {string} functionDeclaration - The function to call.\n   * @param {boolean} awaitPromise - Whether to await the promise returned by the function.\n   * @param {LocalValue[]} [argumentValueList|null] - The list of argument values to pass to the function.\n   * @param {Object} [thisParameter|null] - The value of 'this' parameter for the function.\n   * @param {ResultOwnership} [resultOwnership|null] - The ownership of the result.\n   * @returns {Promise<EvaluateResultSuccess|EvaluateResultException>} - A promise that resolves to the evaluation result or exception.\n   */\n  async callFunctionInRealm(\n    realmId,\n    functionDeclaration,\n    awaitPromise,\n    argumentValueList = null,\n    thisParameter = null,\n    resultOwnership = null,\n  ) {\n    const params = this.getCallFunctionParams(\n      'realm',\n      realmId,\n      null,\n      functionDeclaration,\n      awaitPromise,\n      argumentValueList,\n      thisParameter,\n      resultOwnership,\n    )\n\n    const command = {\n      method: 'script.callFunction',\n      params,\n    }\n\n    let response = await this.bidi.send(command)\n    return this.createEvaluateResult(response)\n  }\n\n  /**\n   * Calls a function in the specified browsing context.\n   *\n   * @param {string} realmId - The ID of the browsing context.\n   * @param {string} functionDeclaration - The function to call.\n   * @param {boolean} awaitPromise - Whether to await the promise returned by the function.\n   * @param {LocalValue[]} [argumentValueList|null] - The list of argument values to pass to the function.\n   * @param {Object} [thisParameter|null] - The value of 'this' parameter for the function.\n   * @param {ResultOwnership} [resultOwnership|null] - The ownership of the result.\n   * @returns {Promise<EvaluateResultSuccess|EvaluateResultException>} - A promise that resolves to the evaluation result or exception.\n   */\n  async callFunctionInBrowsingContext(\n    browsingContextId,\n    functionDeclaration,\n    awaitPromise,\n    argumentValueList = null,\n    thisParameter = null,\n    resultOwnership = null,\n    sandbox = null,\n  ) {\n    const params = this.getCallFunctionParams(\n      'contextTarget',\n      browsingContextId,\n      sandbox,\n      functionDeclaration,\n      awaitPromise,\n      argumentValueList,\n      thisParameter,\n      resultOwnership,\n    )\n\n    const command = {\n      method: 'script.callFunction',\n      params,\n    }\n    const response = await this.bidi.send(command)\n    return this.createEvaluateResult(response)\n  }\n\n  /**\n   * Evaluates a function in the specified realm.\n   *\n   * @param {string} realmId - The ID of the realm.\n   * @param {string} expression - The expression to function to evaluate.\n   * @param {boolean} awaitPromise - Whether to await the promise.\n   * @param {ResultOwnership|null} resultOwnership - The ownership of the result.\n   * @returns {Promise<EvaluateResultSuccess|EvaluateResultException>} - A promise that resolves to the evaluation result or exception.\n   */\n  async evaluateFunctionInRealm(realmId, expression, awaitPromise, resultOwnership = null) {\n    const params = this.getEvaluateParams('realm', realmId, null, expression, awaitPromise, resultOwnership)\n\n    const command = {\n      method: 'script.evaluate',\n      params,\n    }\n\n    let response = await this.bidi.send(command)\n    return this.createEvaluateResult(response)\n  }\n\n  /**\n   * Evaluates a function in the browsing context.\n   *\n   * @param {string} realmId - The ID of the browsing context.\n   * @param {string} expression - The expression to function to evaluate.\n   * @param {boolean} awaitPromise - Whether to await the promise.\n   * @param {ResultOwnership|null} resultOwnership - The ownership of the result.\n   * @returns {Promise<EvaluateResultSuccess|EvaluateResultException>} - A promise that resolves to the evaluation result or exception.\n   */\n  async evaluateFunctionInBrowsingContext(\n    browsingContextId,\n    expression,\n    awaitPromise,\n    resultOwnership = null,\n    sandbox = null,\n  ) {\n    const params = this.getEvaluateParams(\n      'contextTarget',\n      browsingContextId,\n      sandbox,\n      expression,\n      awaitPromise,\n      resultOwnership,\n    )\n\n    const command = {\n      method: 'script.evaluate',\n      params,\n    }\n\n    let response = await this.bidi.send(command)\n    return this.createEvaluateResult(response)\n  }\n\n  /**\n   * Adds a preload script.\n   *\n   * @param {string} functionDeclaration - The declaration of the function to be added as a preload script.\n   * @param {LocalValue[]} [argumentValueList=[]] - The list of argument values to be passed to the preload script function.\n   * @param {string} [sandbox|null] - The sandbox object to be used for the preload script.\n   * @returns {Promise<number>} - A promise that resolves to the added preload script ID.\n   */\n  async addPreloadScript(functionDeclaration, argumentValueList = [], sandbox = null) {\n    const params = {\n      functionDeclaration: functionDeclaration,\n      arguments: argumentValueList,\n    }\n\n    if (sandbox !== null) {\n      params.sandbox = sandbox\n    }\n\n    if (Array.isArray(this._browsingContextIds) && this._browsingContextIds.length > 0) {\n      params.contexts = this._browsingContextIds\n    }\n\n    if (typeof this._browsingContextIds === 'string') {\n      params.contexts = new Array(this._browsingContextIds)\n    }\n\n    if (argumentValueList != null) {\n      let argumentParams = []\n      argumentValueList.forEach((argumentValue) => {\n        argumentParams.push(argumentValue.asMap())\n      })\n      params['arguments'] = argumentParams\n    }\n\n    const command = {\n      method: 'script.addPreloadScript',\n      params,\n    }\n\n    let response = await this.bidi.send(command)\n    return response.result.script\n  }\n\n  /**\n   * Removes a preload script.\n   *\n   * @param {string} script - The ID for the script to be removed.\n   * @returns {Promise<any>} - A promise that resolves with the result of the removal.\n   * @throws {WebDriverError} - If an error occurs during the removal process.\n   */\n  async removePreloadScript(script) {\n    const params = { script: script }\n    const command = {\n      method: 'script.removePreloadScript',\n      params,\n    }\n    let response = await this.bidi.send(command)\n    if ('error' in response) {\n      throw new WebDriverError(response.error)\n    }\n    return response.result\n  }\n\n  getCallFunctionParams(\n    targetType,\n    id,\n    sandbox,\n    functionDeclaration,\n    awaitPromise,\n    argumentValueList = null,\n    thisParameter = null,\n    resultOwnership = null,\n  ) {\n    const params = {\n      functionDeclaration: functionDeclaration,\n      awaitPromise: awaitPromise,\n    }\n    if (targetType === 'contextTarget') {\n      if (sandbox != null) {\n        params['target'] = { context: id, sandbox: sandbox }\n      } else {\n        params['target'] = { context: id }\n      }\n    } else {\n      params['target'] = { realm: id }\n    }\n\n    if (argumentValueList != null) {\n      let argumentParams = []\n      argumentValueList.forEach((argumentValue) => {\n        argumentParams.push(argumentValue.asMap())\n      })\n      params['arguments'] = argumentParams\n    }\n\n    if (thisParameter != null) {\n      params['this'] = thisParameter\n    }\n\n    if (resultOwnership != null) {\n      params['resultOwnership'] = resultOwnership\n    }\n\n    return params\n  }\n\n  getEvaluateParams(targetType, id, sandbox, expression, awaitPromise, resultOwnership = null) {\n    const params = {\n      expression: expression,\n      awaitPromise: awaitPromise,\n    }\n    if (targetType === 'contextTarget') {\n      if (sandbox != null) {\n        params['target'] = { context: id, sandbox: sandbox }\n      } else {\n        params['target'] = { context: id }\n      }\n    } else {\n      params['target'] = { realm: id }\n    }\n    if (resultOwnership != null) {\n      params['resultOwnership'] = resultOwnership\n    }\n\n    return params\n  }\n\n  createEvaluateResult(response) {\n    const type = response.result.type\n    const realmId = response.result.realm\n    let evaluateResult\n\n    if (type === EvaluateResultType.SUCCESS) {\n      const result = response.result.result\n      evaluateResult = new EvaluateResultSuccess(realmId, new RemoteValue(result))\n    } else {\n      const exceptionDetails = response.result.exceptionDetails\n      evaluateResult = new EvaluateResultException(realmId, new ExceptionDetails(exceptionDetails))\n    }\n    return evaluateResult\n  }\n\n  realmInfoMapper(realms) {\n    const realmsList = []\n    realms.forEach((realm) => {\n      realmsList.push(RealmInfo.fromJson(realm))\n    })\n    return realmsList\n  }\n\n  /**\n   * Retrieves all realms.\n   * @returns {Promise<RealmInfo[]>} - A promise that resolves to an array of RealmInfo objects.\n   */\n  async getAllRealms() {\n    const command = {\n      method: 'script.getRealms',\n      params: {},\n    }\n    let response = await this.bidi.send(command)\n    return this.realmInfoMapper(response.result.realms)\n  }\n\n  /**\n   * Retrieves the realms by type.\n   *\n   * @param {Type} type - The type of realms to retrieve.\n   * @returns {Promise<RealmInfo[]>} - A promise that resolves to an array of RealmInfo objects.\n   */\n  async getRealmsByType(type) {\n    const command = {\n      method: 'script.getRealms',\n      params: { type: type },\n    }\n    let response = await this.bidi.send(command)\n    return this.realmInfoMapper(response.result.realms)\n  }\n\n  /**\n   * Retrieves the realms in the specified browsing context.\n   *\n   * @param {string} browsingContext - The browsing context ID.\n   * @returns {Promise<RealmInfo[]>} - A promise that resolves to an array of RealmInfo objects.\n   */\n  async getRealmsInBrowsingContext(browsingContext) {\n    const command = {\n      method: 'script.getRealms',\n      params: { context: browsingContext },\n    }\n    let response = await this.bidi.send(command)\n    return this.realmInfoMapper(response.result.realms)\n  }\n\n  /**\n   * Retrieves the realms in a browsing context based on the specified type.\n   *\n   * @param {string} browsingContext - The browsing context ID.\n   * @param {string} type - The type of realms to retrieve.\n   * @returns {Promise<RealmInfo[]>} - A promise that resolves to an array of RealmInfo objects.\n   */\n  async getRealmsInBrowsingContextByType(browsingContext, type) {\n    const command = {\n      method: 'script.getRealms',\n      params: { context: browsingContext, type: type },\n    }\n    let response = await this.bidi.send(command)\n    return this.realmInfoMapper(response.result.realms)\n  }\n\n  /**\n   * Subscribes to the 'script.message' event and handles the callback function when a message is received.\n   *\n   * @param {Function} callback - The callback function to be executed when a message is received.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async onMessage(callback) {\n    return await this.subscribeAndHandleEvent(ScriptEvent.MESSAGE, callback)\n  }\n\n  /**\n   * Subscribes to the 'script.realmCreated' event and handles it with the provided callback.\n   *\n   * @param {Function} callback - The callback function to handle the 'script.realmCreated' event.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async onRealmCreated(callback) {\n    return await this.subscribeAndHandleEvent(ScriptEvent.REALM_CREATED, callback)\n  }\n\n  /**\n   * Subscribes to the 'script.realmDestroyed' event and handles it with the provided callback function.\n   *\n   * @param {Function} callback - The callback function to be executed when the 'script.realmDestroyed' event occurs.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async onRealmDestroyed(callback) {\n    return await this.subscribeAndHandleEvent(ScriptEvent.REALM_DESTROYED, callback)\n  }\n\n  async subscribeAndHandleEvent(eventType, callback) {\n    if (this._browsingContextIds != null) {\n      await this.bidi.subscribe(eventType, this._browsingContextIds)\n    } else {\n      await this.bidi.subscribe(eventType)\n    }\n\n    let id = this.addCallback(eventType, callback)\n\n    this.ws = await this.bidi.socket\n    this.ws.on('message', (event) => {\n      const { params } = JSON.parse(Buffer.from(event.toString()))\n      if (params) {\n        let response = null\n        if ('channel' in params) {\n          response = new Message(params.channel, new RemoteValue(params.data), new Source(params.source))\n        } else if ('realm' in params) {\n          if (params.type === RealmType.WINDOW) {\n            response = new WindowRealmInfo(params.realm, params.origin, params.type, params.context, params.sandbox)\n          } else if (params.realm !== null && params.type !== null) {\n            response = new RealmInfo(params.realm, params.origin, params.type)\n          } else if (params.realm !== null) {\n            response = params.realm\n          }\n        }\n        this.invokeCallbacks(eventType, response)\n      }\n    })\n\n    return id\n  }\n\n  async close() {\n    if (\n      this._browsingContextIds !== null &&\n      this._browsingContextIds !== undefined &&\n      this._browsingContextIds.length > 0\n    ) {\n      await this.bidi.unsubscribe(\n        'script.message',\n        'script.realmCreated',\n        'script.realmDestroyed',\n        this._browsingContextIds,\n      )\n    } else {\n      await this.bidi.unsubscribe('script.message', 'script.realmCreated', 'script.realmDestroyed')\n    }\n  }\n}\n\nasync function getScriptManagerInstance(browsingContextId, driver) {\n  let instance = new ScriptManager(driver)\n  await instance.init(browsingContextId)\n  return instance\n}\n\nmodule.exports = getScriptManagerInstance\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}