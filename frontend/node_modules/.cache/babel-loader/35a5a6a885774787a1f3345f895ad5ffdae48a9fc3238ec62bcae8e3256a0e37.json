{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst {\n  InvalidArgumentError,\n  NoSuchFrameError\n} = require('../lib/error');\nconst {\n  BrowsingContextInfo\n} = require('./browsingContextTypes');\nconst {\n  SerializationOptions,\n  ReferenceValue,\n  RemoteValue\n} = require('./protocolValue');\nconst {\n  WebElement\n} = require('../lib/webdriver');\nconst {\n  CaptureScreenshotParameters\n} = require('./captureScreenshotParameters');\nconst {\n  CreateContextParameters\n} = require('./createContextParameters');\n\n/**\n * Represents the locator to locate nodes in the browsing context.\n * Described in https://w3c.github.io/webdriver-bidi/#type-browsingContext-Locator.\n */\nclass Locator {\n  static Type = Object.freeze({\n    CSS: 'css',\n    INNER_TEXT: 'innerText',\n    XPATH: 'xpath'\n  });\n  #type;\n  #value;\n  #ignoreCase;\n  #matchType;\n  #maxDepth;\n  constructor(type, value, ignoreCase = undefined, matchType = undefined, maxDepth = undefined) {\n    this.#type = type;\n    this.#value = value;\n    this.#ignoreCase = ignoreCase;\n    this.#matchType = matchType;\n    this.#maxDepth = maxDepth;\n  }\n\n  /**\n   * Creates a new Locator object with CSS selector type.\n   *\n   * @param {string} value - The CSS selector value.\n   * @returns {Locator} A new Locator object with CSS selector type.\n   */\n  static css(value) {\n    return new Locator(Locator.Type.CSS, value);\n  }\n\n  /**\n   * Creates a new Locator object with the given XPath value.\n   *\n   * @param {string} value - The XPath value.\n   * @returns {Locator} A new Locator object.\n   */\n  static xpath(value) {\n    return new Locator(Locator.Type.XPATH, value);\n  }\n\n  /**\n   * Creates a new Locator object with the specified inner text value.\n   *\n   * @param {string} value - The inner text value to locate.\n   * @param {boolean|undefined} [ignoreCase] - Whether to ignore the case when matching the inner text value.\n   * @param {string|undefined} [matchType] - The type of matching to perform (full or partial).\n   * @param {number|undefined} [maxDepth] - The maximum depth to search for the inner text value.\n   * @returns {Locator} A new Locator object with the specified inner text value.\n   */\n  static innerText(value, ignoreCase = undefined, matchType = undefined, maxDepth = undefined) {\n    return new Locator(Locator.Type.INNER_TEXT, value, ignoreCase, matchType, maxDepth);\n  }\n  toMap() {\n    const map = new Map();\n    map.set('type', this.#type.toString());\n    map.set('value', this.#value);\n    map.set('ignoreCase', this.#ignoreCase);\n    map.set('matchType', this.#matchType);\n    map.set('maxDepth', this.#maxDepth);\n    return map;\n  }\n}\n\n/**\n * Represents the contains under BrowsingContext module commands.\n * Described in https://w3c.github.io/webdriver-bidi/#module-browsingContext\n * Each browsing context command requires a browsing context id.\n * Hence, this class represent browsing context lifecycle.\n */\nclass BrowsingContext {\n  constructor(driver) {\n    this._driver = driver;\n  }\n\n  /**\n   * @returns id\n   */\n  get id() {\n    return this._id;\n  }\n  async init({\n    browsingContextId = undefined,\n    type = undefined,\n    createParameters = undefined\n  }) {\n    if (!(await this._driver.getCapabilities()).get('webSocketUrl')) {\n      throw Error('WebDriver instance must support BiDi protocol');\n    }\n    if (browsingContextId === undefined && type === undefined && createParameters === undefined) {\n      throw Error('Either BrowsingContextId or Type or CreateParameters must be provided');\n    }\n    if (type === undefined && createParameters !== undefined) {\n      throw Error('Type must be provided with CreateParameters');\n    }\n    if (type !== undefined && !['window', 'tab'].includes(type)) {\n      throw Error(`Valid types are 'window' & 'tab'. Received: ${type}`);\n    }\n    this.bidi = await this._driver.getBidi();\n    this._id = browsingContextId === undefined ? (await this.create(type, createParameters))['result']['context'] : browsingContextId;\n  }\n\n  /**\n   * Creates a browsing context for the given type with the given parameters\n   */\n  async create(type, createParameters = undefined) {\n    if (createParameters !== undefined && !createParameters instanceof CreateContextParameters) {\n      throw Error(`Pass in the instance of CreateContextParameters. Received: ${createParameters}`);\n    }\n    let parameters = new Map();\n    parameters.set('type', type);\n    if (createParameters !== undefined) {\n      createParameters.asMap().forEach((value, key) => {\n        parameters.set(key, value);\n      });\n    }\n    const params = {\n      method: 'browsingContext.create',\n      params: Object.fromEntries(parameters)\n    };\n    return await this.bidi.send(params);\n  }\n\n  /**\n   * @param url the url to navigate to\n   * @param readinessState type of readiness state: \"none\" / \"interactive\" / \"complete\"\n   * @returns NavigateResult object\n   */\n  async navigate(url, readinessState = undefined) {\n    if (readinessState !== undefined && !['none', 'interactive', 'complete'].includes(readinessState)) {\n      throw Error(`Valid readiness states are 'none', 'interactive' & 'complete'. Received: ${readinessState}`);\n    }\n    const params = {\n      method: 'browsingContext.navigate',\n      params: {\n        context: this._id,\n        url: url,\n        wait: readinessState\n      }\n    };\n    const navigateResult = (await this.bidi.send(params))['result'];\n    return new NavigateResult(navigateResult['url'], navigateResult['navigation']);\n  }\n\n  /**\n   * @param maxDepth the max depth of the descendents of browsing context tree\n   * @returns BrowsingContextInfo object\n   */\n  async getTree(maxDepth = undefined) {\n    const params = {\n      method: 'browsingContext.getTree',\n      params: {\n        root: this._id,\n        maxDepth: maxDepth\n      }\n    };\n    let result = await this.bidi.send(params);\n    if ('error' in result) {\n      throw Error(result['error']);\n    }\n    result = result['result']['contexts'][0];\n    return new BrowsingContextInfo(result['context'], result['url'], result['children'], result['parent']);\n  }\n\n  /**\n   * @returns {Promise<Array<BrowsingContextInfo>>} A Promise that resolves to an array of BrowsingContextInfo objects representing the top-level browsing contexts.\n   */\n  async getTopLevelContexts() {\n    const params = {\n      method: 'browsingContext.getTree',\n      params: {}\n    };\n    let result = await this.bidi.send(params);\n    if ('error' in result) {\n      throw Error(result['error']);\n    }\n    const contexts = result['result']['contexts'];\n    const browsingContexts = contexts.map(context => {\n      return new BrowsingContextInfo(context['id'], context['url'], context['children'], context['parent']);\n    });\n    return browsingContexts;\n  }\n\n  /**\n   * Closes the browsing context\n   * @returns {Promise<void>}\n   */\n  async close() {\n    const params = {\n      method: 'browsingContext.close',\n      params: {\n        context: this._id\n      }\n    };\n    await this.bidi.send(params);\n  }\n\n  /**\n   * Prints PDF of the webpage\n   * @param options print options given by the user\n   * @returns PrintResult object\n   */\n  async printPage(options = {}) {\n    let params = {\n      method: 'browsingContext.print',\n      // Setting default values for parameters\n      params: {\n        context: this._id,\n        background: false,\n        margin: {\n          bottom: 1.0,\n          left: 1.0,\n          right: 1.0,\n          top: 1.0\n        },\n        orientation: 'portrait',\n        page: {\n          height: 27.94,\n          width: 21.59\n        },\n        pageRanges: [],\n        scale: 1.0,\n        shrinkToFit: true\n      }\n    };\n\n    // Updating parameter values based on the options passed\n    params.params = this._driver.validatePrintPageParams(options, params.params);\n    const response = await this.bidi.send(params);\n    return new PrintResult(response.result.data);\n  }\n\n  /**\n   * Captures a screenshot of the browsing context.\n   *\n   * @param {CaptureScreenshotParameters|undefined} [captureScreenshotParameters] - Optional parameters for capturing the screenshot.\n   * @returns {Promise<string>} - A promise that resolves to the base64-encoded string representation of the captured screenshot.\n   * @throws {InvalidArgumentError} - If the provided captureScreenshotParameters is not an instance of CaptureScreenshotParameters.\n   */\n  async captureScreenshot(captureScreenshotParameters = undefined) {\n    if (captureScreenshotParameters !== undefined && !(captureScreenshotParameters instanceof CaptureScreenshotParameters)) {\n      throw new InvalidArgumentError(`Pass in a CaptureScreenshotParameters object. Received: ${captureScreenshotParameters}`);\n    }\n    const screenshotParams = new Map();\n    screenshotParams.set('context', this._id);\n    if (captureScreenshotParameters !== undefined) {\n      captureScreenshotParameters.asMap().forEach((value, key) => {\n        screenshotParams.set(key, value);\n      });\n    }\n    let params = {\n      method: 'browsingContext.captureScreenshot',\n      params: Object.fromEntries(screenshotParams)\n    };\n    const response = await this.bidi.send(params);\n    this.checkErrorInScreenshot(response);\n    return response['result']['data'];\n  }\n  async captureBoxScreenshot(x, y, width, height) {\n    let params = {\n      method: 'browsingContext.captureScreenshot',\n      params: {\n        context: this._id,\n        clip: {\n          type: 'box',\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        }\n      }\n    };\n    const response = await this.bidi.send(params);\n    this.checkErrorInScreenshot(response);\n    return response['result']['data'];\n  }\n\n  /**\n   * Captures a screenshot of a specific element within the browsing context.\n   * @param {string} sharedId - The shared ID of the element to capture.\n   * @param {string} [handle] - The handle of the element to capture (optional).\n   * @returns {Promise<string>} A promise that resolves to the base64-encoded screenshot data.\n   */\n  async captureElementScreenshot(sharedId, handle = undefined) {\n    let params = {\n      method: 'browsingContext.captureScreenshot',\n      params: {\n        context: this._id,\n        clip: {\n          type: 'element',\n          element: {\n            sharedId: sharedId,\n            handle: handle\n          }\n        }\n      }\n    };\n    const response = await this.bidi.send(params);\n    this.checkErrorInScreenshot(response);\n    return response['result']['data'];\n  }\n  checkErrorInScreenshot(response) {\n    if ('error' in response) {\n      const {\n        error,\n        msg\n      } = response;\n      switch (error) {\n        case 'invalid argument':\n          throw new InvalidArgumentError(msg);\n        case 'no such frame':\n          throw new NoSuchFrameError(msg);\n      }\n    }\n  }\n\n  /**\n   * Activates and focuses the top-level browsing context.\n   * @returns {Promise<void>} A promise that resolves when the browsing context is activated.\n   * @throws {Error} If there is an error while activating the browsing context.\n   */\n  async activate() {\n    const params = {\n      method: 'browsingContext.activate',\n      params: {\n        context: this._id\n      }\n    };\n    let result = await this.bidi.send(params);\n    if ('error' in result) {\n      throw Error(result['error']);\n    }\n  }\n\n  /**\n   * Handles a user prompt in the browsing context.\n   *\n   * @param {boolean} [accept] - Optional. Indicates whether to accept or dismiss the prompt.\n   * @param {string} [userText] - Optional. The text to enter.\n   * @throws {Error} If an error occurs while handling the user prompt.\n   */\n  async handleUserPrompt(accept = undefined, userText = undefined) {\n    const params = {\n      method: 'browsingContext.handleUserPrompt',\n      params: {\n        context: this._id,\n        accept: accept,\n        userText: userText\n      }\n    };\n    let result = await this.bidi.send(params);\n    if ('error' in result) {\n      throw Error(result['error']);\n    }\n  }\n\n  /**\n   * Reloads the current browsing context.\n   *\n   * @param {boolean} [ignoreCache] - Whether to ignore the cache when reloading.\n   * @param {string} [readinessState] - The readiness state to wait for before returning.\n   *        Valid readiness states are 'none', 'interactive', and 'complete'.\n   * @returns {Promise<NavigateResult>} - A promise that resolves to the result of the reload operation.\n   * @throws {Error} - If an invalid readiness state is provided.\n   */\n  async reload(ignoreCache = undefined, readinessState = undefined) {\n    if (readinessState !== undefined && !['none', 'interactive', 'complete'].includes(readinessState)) {\n      throw Error(`Valid readiness states are 'none', 'interactive' & 'complete'. Received: ${readinessState}`);\n    }\n    const params = {\n      method: 'browsingContext.reload',\n      params: {\n        context: this._id,\n        ignoreCache: ignoreCache,\n        wait: readinessState\n      }\n    };\n    const navigateResult = (await this.bidi.send(params))['result'];\n    return new NavigateResult(navigateResult['url'], navigateResult['navigation']);\n  }\n\n  /**\n   * Sets the viewport size and device pixel ratio for the browsing context.\n   * @param {number} width - The width of the viewport.\n   * @param {number} height - The height of the viewport.\n   * @param {number} [devicePixelRatio] - The device pixel ratio (optional)\n   * @throws {Error} If an error occurs while setting the viewport.\n   */\n  async setViewport(width, height, devicePixelRatio = undefined) {\n    const params = {\n      method: 'browsingContext.setViewport',\n      params: {\n        context: this._id,\n        viewport: {\n          width: width,\n          height: height\n        },\n        devicePixelRatio: devicePixelRatio\n      }\n    };\n    let result = await this.bidi.send(params);\n    if ('error' in result) {\n      throw Error(result['error']);\n    }\n  }\n\n  /**\n   * Traverses the browsing context history by a given delta.\n   *\n   * @param {number} delta - The delta value to traverse the history. A positive value moves forward, while a negative value moves backward.\n   * @returns {Promise<void>} - A promise that resolves when the history traversal is complete.\n   */\n  async traverseHistory(delta) {\n    const params = {\n      method: 'browsingContext.traverseHistory',\n      params: {\n        context: this._id,\n        delta: delta\n      }\n    };\n    await this.bidi.send(params);\n  }\n\n  /**\n   * Moves the browsing context forward by one step in the history.\n   * @returns {Promise<void>} A promise that resolves when the browsing context has moved forward.\n   */\n  async forward() {\n    await this.traverseHistory(1);\n  }\n\n  /**\n   * Navigates the browsing context to the previous page in the history.\n   * @returns {Promise<void>} A promise that resolves when the navigation is complete.\n   */\n  async back() {\n    await this.traverseHistory(-1);\n  }\n\n  /**\n   * Locates nodes in the browsing context.\n   *\n   * @param {Locator} locator - The locator object used to locate the nodes.\n   * @param {number} [maxNodeCount] - The maximum number of nodes to locate (optional).\n   * @param {string} [sandbox] - The sandbox name for locating nodes (optional).\n   * @param {SerializationOptions} [serializationOptions] - The serialization options for locating nodes (optional).\n   * @param {ReferenceValue[]} [startNodes] - The array of start nodes for locating nodes (optional).\n   * @returns {Promise<RemoteValue[]>} - A promise that resolves to the arrays of located nodes.\n   * @throws {Error} - If the locator is not an instance of Locator.\n   * @throws {Error} - If the serializationOptions is provided but not an instance of SerializationOptions.\n   * @throws {Error} - If the startNodes is provided but not an array of ReferenceValue objects.\n   * @throws {Error} - If any of the startNodes is not an instance of ReferenceValue.\n   */\n  async locateNodes(locator, maxNodeCount = undefined, sandbox = undefined, serializationOptions = undefined, startNodes = undefined) {\n    if (!(locator instanceof Locator)) {\n      throw Error(`Pass in a Locator object. Received: ${locator}`);\n    }\n    if (serializationOptions !== undefined && !(serializationOptions instanceof SerializationOptions)) {\n      throw Error(`Pass in SerializationOptions object. Received: ${serializationOptions} `);\n    }\n    if (startNodes !== undefined && !Array.isArray(startNodes)) {\n      throw Error(`Pass in an array of ReferenceValue objects. Received: ${startNodes}`);\n    }\n    let startNodesSerialized = undefined;\n    if (startNodes !== undefined && Array.isArray(startNodes)) {\n      startNodesSerialized = [];\n      startNodes.forEach(node => {\n        if (!(node instanceof ReferenceValue)) {\n          throw Error(`Pass in a ReferenceValue object. Received: ${node}`);\n        } else {\n          startNodesSerialized.push(node.asMap());\n        }\n      });\n    }\n    const params = {\n      method: 'browsingContext.locateNodes',\n      params: {\n        context: this._id,\n        locator: Object.fromEntries(locator.toMap()),\n        maxNodeCount: maxNodeCount,\n        sandbox: sandbox,\n        serializationOptions: serializationOptions,\n        startNodes: startNodesSerialized\n      }\n    };\n    let response = await this.bidi.send(params);\n    if ('error' in response) {\n      throw Error(response['error']);\n    }\n    const nodes = response.result.nodes;\n    const remoteValues = [];\n    nodes.forEach(node => {\n      remoteValues.push(new RemoteValue(node));\n    });\n    return remoteValues;\n  }\n\n  /**\n   * Locates a single node in the browsing context.\n   *\n   * @param {Locator} locator - The locator used to find the node.\n   * @param {string} [sandbox] - The sandbox of the node (optional).\n   * @param {SerializationOptions} [serializationOptions] - The serialization options for the node (optional).\n   * @param {Array} [startNodes] - The starting nodes for the search (optional).\n   * @returns {Promise<RemoteValue>} - A promise that resolves to the located node.\n   */\n  async locateNode(locator, sandbox = undefined, serializationOptions = undefined, startNodes = undefined) {\n    const elements = await this.locateNodes(locator, 1, sandbox, serializationOptions, startNodes);\n    return elements[0];\n  }\n  async locateElement(locator) {\n    const elements = await this.locateNodes(locator, 1);\n    return new WebElement(this._driver, elements[0].sharedId);\n  }\n  async locateElements(locator) {\n    const elements = await this.locateNodes(locator);\n    let webElements = [];\n    elements.forEach(element => {\n      webElements.push(new WebElement(this._driver, element.sharedId));\n    });\n    return webElements;\n  }\n}\n\n/**\n * Represents the result of a navigation operation.\n */\nclass NavigateResult {\n  constructor(url, navigationId) {\n    this._url = url;\n    this._navigationId = navigationId;\n  }\n\n  /**\n   * Gets the URL of the navigated page.\n   * @returns {string} The URL of the navigated page.\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Gets the ID of the navigation operation.\n   * @returns {number} The ID of the navigation operation.\n   */\n  get navigationId() {\n    return this._navigationId;\n  }\n}\n\n/**\n * Represents a print result.\n */\nclass PrintResult {\n  constructor(data) {\n    this._data = data;\n  }\n\n  /**\n   * Gets the data associated with the print result.\n   * @returns {any} The data associated with the print result.\n   */\n  get data() {\n    return this._data;\n  }\n}\n\n/**\n * initiate browsing context instance and return\n * @param driver\n * @param browsingContextId The browsing context of current window/tab\n * @param type \"window\" or \"tab\"\n * @param createParameters The parameters for creating a new browsing context\n * @returns {Promise<BrowsingContext>}\n */\nasync function getBrowsingContextInstance(driver, {\n  browsingContextId = undefined,\n  type = undefined,\n  createParameters = undefined\n}) {\n  let instance = new BrowsingContext(driver);\n  await instance.init({\n    browsingContextId,\n    type,\n    createParameters\n  });\n  return instance;\n}\nmodule.exports = getBrowsingContextInstance;\nmodule.exports.Locator = Locator;","map":{"version":3,"names":["InvalidArgumentError","NoSuchFrameError","require","BrowsingContextInfo","SerializationOptions","ReferenceValue","RemoteValue","WebElement","CaptureScreenshotParameters","CreateContextParameters","Locator","Type","Object","freeze","CSS","INNER_TEXT","XPATH","type","value","ignoreCase","matchType","maxDepth","constructor","undefined","css","xpath","innerText","toMap","map","Map","set","toString","BrowsingContext","driver","_driver","id","_id","init","browsingContextId","createParameters","getCapabilities","get","Error","includes","bidi","getBidi","create","parameters","asMap","forEach","key","params","method","fromEntries","send","navigate","url","readinessState","context","wait","navigateResult","NavigateResult","getTree","root","result","getTopLevelContexts","contexts","browsingContexts","close","printPage","options","background","margin","bottom","left","right","top","orientation","page","height","width","pageRanges","scale","shrinkToFit","validatePrintPageParams","response","PrintResult","data","captureScreenshot","captureScreenshotParameters","screenshotParams","checkErrorInScreenshot","captureBoxScreenshot","x","y","clip","captureElementScreenshot","sharedId","handle","element","error","msg","activate","handleUserPrompt","accept","userText","reload","ignoreCache","setViewport","devicePixelRatio","viewport","traverseHistory","delta","forward","back","locateNodes","locator","maxNodeCount","sandbox","serializationOptions","startNodes","Array","isArray","startNodesSerialized","node","push","nodes","remoteValues","locateNode","elements","locateElement","locateElements","webElements","navigationId","_url","_navigationId","_data","getBrowsingContextInstance","instance","module","exports"],"sources":["C:/Users/rayan/Documents/GitHub/Project-Outils/node_modules/selenium-webdriver/bidi/browsingContext.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst { InvalidArgumentError, NoSuchFrameError } = require('../lib/error')\nconst { BrowsingContextInfo } = require('./browsingContextTypes')\nconst { SerializationOptions, ReferenceValue, RemoteValue } = require('./protocolValue')\nconst { WebElement } = require('../lib/webdriver')\nconst { CaptureScreenshotParameters } = require('./captureScreenshotParameters')\nconst { CreateContextParameters } = require('./createContextParameters')\n\n/**\n * Represents the locator to locate nodes in the browsing context.\n * Described in https://w3c.github.io/webdriver-bidi/#type-browsingContext-Locator.\n */\nclass Locator {\n  static Type = Object.freeze({\n    CSS: 'css',\n    INNER_TEXT: 'innerText',\n    XPATH: 'xpath',\n  })\n\n  #type\n  #value\n  #ignoreCase\n  #matchType\n  #maxDepth\n\n  constructor(type, value, ignoreCase = undefined, matchType = undefined, maxDepth = undefined) {\n    this.#type = type\n    this.#value = value\n    this.#ignoreCase = ignoreCase\n    this.#matchType = matchType\n    this.#maxDepth = maxDepth\n  }\n\n  /**\n   * Creates a new Locator object with CSS selector type.\n   *\n   * @param {string} value - The CSS selector value.\n   * @returns {Locator} A new Locator object with CSS selector type.\n   */\n  static css(value) {\n    return new Locator(Locator.Type.CSS, value)\n  }\n\n  /**\n   * Creates a new Locator object with the given XPath value.\n   *\n   * @param {string} value - The XPath value.\n   * @returns {Locator} A new Locator object.\n   */\n  static xpath(value) {\n    return new Locator(Locator.Type.XPATH, value)\n  }\n\n  /**\n   * Creates a new Locator object with the specified inner text value.\n   *\n   * @param {string} value - The inner text value to locate.\n   * @param {boolean|undefined} [ignoreCase] - Whether to ignore the case when matching the inner text value.\n   * @param {string|undefined} [matchType] - The type of matching to perform (full or partial).\n   * @param {number|undefined} [maxDepth] - The maximum depth to search for the inner text value.\n   * @returns {Locator} A new Locator object with the specified inner text value.\n   */\n  static innerText(value, ignoreCase = undefined, matchType = undefined, maxDepth = undefined) {\n    return new Locator(Locator.Type.INNER_TEXT, value, ignoreCase, matchType, maxDepth)\n  }\n\n  toMap() {\n    const map = new Map()\n\n    map.set('type', this.#type.toString())\n    map.set('value', this.#value)\n    map.set('ignoreCase', this.#ignoreCase)\n    map.set('matchType', this.#matchType)\n    map.set('maxDepth', this.#maxDepth)\n\n    return map\n  }\n}\n\n/**\n * Represents the contains under BrowsingContext module commands.\n * Described in https://w3c.github.io/webdriver-bidi/#module-browsingContext\n * Each browsing context command requires a browsing context id.\n * Hence, this class represent browsing context lifecycle.\n */\nclass BrowsingContext {\n  constructor(driver) {\n    this._driver = driver\n  }\n\n  /**\n   * @returns id\n   */\n  get id() {\n    return this._id\n  }\n\n  async init({ browsingContextId = undefined, type = undefined, createParameters = undefined }) {\n    if (!(await this._driver.getCapabilities()).get('webSocketUrl')) {\n      throw Error('WebDriver instance must support BiDi protocol')\n    }\n\n    if (browsingContextId === undefined && type === undefined && createParameters === undefined) {\n      throw Error('Either BrowsingContextId or Type or CreateParameters must be provided')\n    }\n\n    if (type === undefined && createParameters !== undefined) {\n      throw Error('Type must be provided with CreateParameters')\n    }\n\n    if (type !== undefined && !['window', 'tab'].includes(type)) {\n      throw Error(`Valid types are 'window' & 'tab'. Received: ${type}`)\n    }\n\n    this.bidi = await this._driver.getBidi()\n    this._id =\n      browsingContextId === undefined\n        ? (await this.create(type, createParameters))['result']['context']\n        : browsingContextId\n  }\n\n  /**\n   * Creates a browsing context for the given type with the given parameters\n   */\n  async create(type, createParameters = undefined) {\n    if (createParameters !== undefined && (!createParameters) instanceof CreateContextParameters) {\n      throw Error(`Pass in the instance of CreateContextParameters. Received: ${createParameters}`)\n    }\n\n    let parameters = new Map()\n    parameters.set('type', type)\n\n    if (createParameters !== undefined) {\n      createParameters.asMap().forEach((value, key) => {\n        parameters.set(key, value)\n      })\n    }\n\n    const params = {\n      method: 'browsingContext.create',\n      params: Object.fromEntries(parameters),\n    }\n    return await this.bidi.send(params)\n  }\n\n  /**\n   * @param url the url to navigate to\n   * @param readinessState type of readiness state: \"none\" / \"interactive\" / \"complete\"\n   * @returns NavigateResult object\n   */\n  async navigate(url, readinessState = undefined) {\n    if (readinessState !== undefined && !['none', 'interactive', 'complete'].includes(readinessState)) {\n      throw Error(`Valid readiness states are 'none', 'interactive' & 'complete'. Received: ${readinessState}`)\n    }\n\n    const params = {\n      method: 'browsingContext.navigate',\n      params: {\n        context: this._id,\n        url: url,\n        wait: readinessState,\n      },\n    }\n    const navigateResult = (await this.bidi.send(params))['result']\n\n    return new NavigateResult(navigateResult['url'], navigateResult['navigation'])\n  }\n\n  /**\n   * @param maxDepth the max depth of the descendents of browsing context tree\n   * @returns BrowsingContextInfo object\n   */\n  async getTree(maxDepth = undefined) {\n    const params = {\n      method: 'browsingContext.getTree',\n      params: {\n        root: this._id,\n        maxDepth: maxDepth,\n      },\n    }\n\n    let result = await this.bidi.send(params)\n    if ('error' in result) {\n      throw Error(result['error'])\n    }\n\n    result = result['result']['contexts'][0]\n    return new BrowsingContextInfo(result['context'], result['url'], result['children'], result['parent'])\n  }\n\n  /**\n   * @returns {Promise<Array<BrowsingContextInfo>>} A Promise that resolves to an array of BrowsingContextInfo objects representing the top-level browsing contexts.\n   */\n  async getTopLevelContexts() {\n    const params = {\n      method: 'browsingContext.getTree',\n      params: {},\n    }\n\n    let result = await this.bidi.send(params)\n    if ('error' in result) {\n      throw Error(result['error'])\n    }\n\n    const contexts = result['result']['contexts']\n    const browsingContexts = contexts.map((context) => {\n      return new BrowsingContextInfo(context['id'], context['url'], context['children'], context['parent'])\n    })\n    return browsingContexts\n  }\n\n  /**\n   * Closes the browsing context\n   * @returns {Promise<void>}\n   */\n  async close() {\n    const params = {\n      method: 'browsingContext.close',\n      params: {\n        context: this._id,\n      },\n    }\n    await this.bidi.send(params)\n  }\n\n  /**\n   * Prints PDF of the webpage\n   * @param options print options given by the user\n   * @returns PrintResult object\n   */\n  async printPage(options = {}) {\n    let params = {\n      method: 'browsingContext.print',\n      // Setting default values for parameters\n      params: {\n        context: this._id,\n        background: false,\n        margin: {\n          bottom: 1.0,\n          left: 1.0,\n          right: 1.0,\n          top: 1.0,\n        },\n        orientation: 'portrait',\n        page: {\n          height: 27.94,\n          width: 21.59,\n        },\n        pageRanges: [],\n        scale: 1.0,\n        shrinkToFit: true,\n      },\n    }\n\n    // Updating parameter values based on the options passed\n    params.params = this._driver.validatePrintPageParams(options, params.params)\n\n    const response = await this.bidi.send(params)\n    return new PrintResult(response.result.data)\n  }\n\n  /**\n   * Captures a screenshot of the browsing context.\n   *\n   * @param {CaptureScreenshotParameters|undefined} [captureScreenshotParameters] - Optional parameters for capturing the screenshot.\n   * @returns {Promise<string>} - A promise that resolves to the base64-encoded string representation of the captured screenshot.\n   * @throws {InvalidArgumentError} - If the provided captureScreenshotParameters is not an instance of CaptureScreenshotParameters.\n   */\n  async captureScreenshot(captureScreenshotParameters = undefined) {\n    if (\n      captureScreenshotParameters !== undefined &&\n      !(captureScreenshotParameters instanceof CaptureScreenshotParameters)\n    ) {\n      throw new InvalidArgumentError(\n        `Pass in a CaptureScreenshotParameters object. Received: ${captureScreenshotParameters}`,\n      )\n    }\n\n    const screenshotParams = new Map()\n    screenshotParams.set('context', this._id)\n    if (captureScreenshotParameters !== undefined) {\n      captureScreenshotParameters.asMap().forEach((value, key) => {\n        screenshotParams.set(key, value)\n      })\n    }\n\n    let params = {\n      method: 'browsingContext.captureScreenshot',\n      params: Object.fromEntries(screenshotParams),\n    }\n\n    const response = await this.bidi.send(params)\n    this.checkErrorInScreenshot(response)\n    return response['result']['data']\n  }\n\n  async captureBoxScreenshot(x, y, width, height) {\n    let params = {\n      method: 'browsingContext.captureScreenshot',\n      params: {\n        context: this._id,\n        clip: {\n          type: 'box',\n          x: x,\n          y: y,\n          width: width,\n          height: height,\n        },\n      },\n    }\n\n    const response = await this.bidi.send(params)\n    this.checkErrorInScreenshot(response)\n    return response['result']['data']\n  }\n\n  /**\n   * Captures a screenshot of a specific element within the browsing context.\n   * @param {string} sharedId - The shared ID of the element to capture.\n   * @param {string} [handle] - The handle of the element to capture (optional).\n   * @returns {Promise<string>} A promise that resolves to the base64-encoded screenshot data.\n   */\n  async captureElementScreenshot(sharedId, handle = undefined) {\n    let params = {\n      method: 'browsingContext.captureScreenshot',\n      params: {\n        context: this._id,\n        clip: {\n          type: 'element',\n          element: {\n            sharedId: sharedId,\n            handle: handle,\n          },\n        },\n      },\n    }\n\n    const response = await this.bidi.send(params)\n    this.checkErrorInScreenshot(response)\n    return response['result']['data']\n  }\n\n  checkErrorInScreenshot(response) {\n    if ('error' in response) {\n      const { error, msg } = response\n\n      switch (error) {\n        case 'invalid argument':\n          throw new InvalidArgumentError(msg)\n\n        case 'no such frame':\n          throw new NoSuchFrameError(msg)\n      }\n    }\n  }\n\n  /**\n   * Activates and focuses the top-level browsing context.\n   * @returns {Promise<void>} A promise that resolves when the browsing context is activated.\n   * @throws {Error} If there is an error while activating the browsing context.\n   */\n  async activate() {\n    const params = {\n      method: 'browsingContext.activate',\n      params: {\n        context: this._id,\n      },\n    }\n\n    let result = await this.bidi.send(params)\n    if ('error' in result) {\n      throw Error(result['error'])\n    }\n  }\n\n  /**\n   * Handles a user prompt in the browsing context.\n   *\n   * @param {boolean} [accept] - Optional. Indicates whether to accept or dismiss the prompt.\n   * @param {string} [userText] - Optional. The text to enter.\n   * @throws {Error} If an error occurs while handling the user prompt.\n   */\n  async handleUserPrompt(accept = undefined, userText = undefined) {\n    const params = {\n      method: 'browsingContext.handleUserPrompt',\n      params: {\n        context: this._id,\n        accept: accept,\n        userText: userText,\n      },\n    }\n\n    let result = await this.bidi.send(params)\n    if ('error' in result) {\n      throw Error(result['error'])\n    }\n  }\n\n  /**\n   * Reloads the current browsing context.\n   *\n   * @param {boolean} [ignoreCache] - Whether to ignore the cache when reloading.\n   * @param {string} [readinessState] - The readiness state to wait for before returning.\n   *        Valid readiness states are 'none', 'interactive', and 'complete'.\n   * @returns {Promise<NavigateResult>} - A promise that resolves to the result of the reload operation.\n   * @throws {Error} - If an invalid readiness state is provided.\n   */\n  async reload(ignoreCache = undefined, readinessState = undefined) {\n    if (readinessState !== undefined && !['none', 'interactive', 'complete'].includes(readinessState)) {\n      throw Error(`Valid readiness states are 'none', 'interactive' & 'complete'. Received: ${readinessState}`)\n    }\n\n    const params = {\n      method: 'browsingContext.reload',\n      params: {\n        context: this._id,\n        ignoreCache: ignoreCache,\n        wait: readinessState,\n      },\n    }\n    const navigateResult = (await this.bidi.send(params))['result']\n\n    return new NavigateResult(navigateResult['url'], navigateResult['navigation'])\n  }\n\n  /**\n   * Sets the viewport size and device pixel ratio for the browsing context.\n   * @param {number} width - The width of the viewport.\n   * @param {number} height - The height of the viewport.\n   * @param {number} [devicePixelRatio] - The device pixel ratio (optional)\n   * @throws {Error} If an error occurs while setting the viewport.\n   */\n  async setViewport(width, height, devicePixelRatio = undefined) {\n    const params = {\n      method: 'browsingContext.setViewport',\n      params: {\n        context: this._id,\n        viewport: { width: width, height: height },\n        devicePixelRatio: devicePixelRatio,\n      },\n    }\n    let result = await this.bidi.send(params)\n    if ('error' in result) {\n      throw Error(result['error'])\n    }\n  }\n\n  /**\n   * Traverses the browsing context history by a given delta.\n   *\n   * @param {number} delta - The delta value to traverse the history. A positive value moves forward, while a negative value moves backward.\n   * @returns {Promise<void>} - A promise that resolves when the history traversal is complete.\n   */\n  async traverseHistory(delta) {\n    const params = {\n      method: 'browsingContext.traverseHistory',\n      params: {\n        context: this._id,\n        delta: delta,\n      },\n    }\n    await this.bidi.send(params)\n  }\n\n  /**\n   * Moves the browsing context forward by one step in the history.\n   * @returns {Promise<void>} A promise that resolves when the browsing context has moved forward.\n   */\n  async forward() {\n    await this.traverseHistory(1)\n  }\n\n  /**\n   * Navigates the browsing context to the previous page in the history.\n   * @returns {Promise<void>} A promise that resolves when the navigation is complete.\n   */\n  async back() {\n    await this.traverseHistory(-1)\n  }\n\n  /**\n   * Locates nodes in the browsing context.\n   *\n   * @param {Locator} locator - The locator object used to locate the nodes.\n   * @param {number} [maxNodeCount] - The maximum number of nodes to locate (optional).\n   * @param {string} [sandbox] - The sandbox name for locating nodes (optional).\n   * @param {SerializationOptions} [serializationOptions] - The serialization options for locating nodes (optional).\n   * @param {ReferenceValue[]} [startNodes] - The array of start nodes for locating nodes (optional).\n   * @returns {Promise<RemoteValue[]>} - A promise that resolves to the arrays of located nodes.\n   * @throws {Error} - If the locator is not an instance of Locator.\n   * @throws {Error} - If the serializationOptions is provided but not an instance of SerializationOptions.\n   * @throws {Error} - If the startNodes is provided but not an array of ReferenceValue objects.\n   * @throws {Error} - If any of the startNodes is not an instance of ReferenceValue.\n   */\n  async locateNodes(\n    locator,\n    maxNodeCount = undefined,\n    sandbox = undefined,\n    serializationOptions = undefined,\n    startNodes = undefined,\n  ) {\n    if (!(locator instanceof Locator)) {\n      throw Error(`Pass in a Locator object. Received: ${locator}`)\n    }\n\n    if (serializationOptions !== undefined && !(serializationOptions instanceof SerializationOptions)) {\n      throw Error(`Pass in SerializationOptions object. Received: ${serializationOptions} `)\n    }\n\n    if (startNodes !== undefined && !Array.isArray(startNodes)) {\n      throw Error(`Pass in an array of ReferenceValue objects. Received: ${startNodes}`)\n    }\n\n    let startNodesSerialized = undefined\n\n    if (startNodes !== undefined && Array.isArray(startNodes)) {\n      startNodesSerialized = []\n      startNodes.forEach((node) => {\n        if (!(node instanceof ReferenceValue)) {\n          throw Error(`Pass in a ReferenceValue object. Received: ${node}`)\n        } else {\n          startNodesSerialized.push(node.asMap())\n        }\n      })\n    }\n\n    const params = {\n      method: 'browsingContext.locateNodes',\n      params: {\n        context: this._id,\n        locator: Object.fromEntries(locator.toMap()),\n        maxNodeCount: maxNodeCount,\n        sandbox: sandbox,\n        serializationOptions: serializationOptions,\n        startNodes: startNodesSerialized,\n      },\n    }\n\n    let response = await this.bidi.send(params)\n    if ('error' in response) {\n      throw Error(response['error'])\n    }\n\n    const nodes = response.result.nodes\n    const remoteValues = []\n\n    nodes.forEach((node) => {\n      remoteValues.push(new RemoteValue(node))\n    })\n    return remoteValues\n  }\n\n  /**\n   * Locates a single node in the browsing context.\n   *\n   * @param {Locator} locator - The locator used to find the node.\n   * @param {string} [sandbox] - The sandbox of the node (optional).\n   * @param {SerializationOptions} [serializationOptions] - The serialization options for the node (optional).\n   * @param {Array} [startNodes] - The starting nodes for the search (optional).\n   * @returns {Promise<RemoteValue>} - A promise that resolves to the located node.\n   */\n  async locateNode(locator, sandbox = undefined, serializationOptions = undefined, startNodes = undefined) {\n    const elements = await this.locateNodes(locator, 1, sandbox, serializationOptions, startNodes)\n    return elements[0]\n  }\n\n  async locateElement(locator) {\n    const elements = await this.locateNodes(locator, 1)\n    return new WebElement(this._driver, elements[0].sharedId)\n  }\n\n  async locateElements(locator) {\n    const elements = await this.locateNodes(locator)\n\n    let webElements = []\n    elements.forEach((element) => {\n      webElements.push(new WebElement(this._driver, element.sharedId))\n    })\n    return webElements\n  }\n}\n\n/**\n * Represents the result of a navigation operation.\n */\nclass NavigateResult {\n  constructor(url, navigationId) {\n    this._url = url\n    this._navigationId = navigationId\n  }\n\n  /**\n   * Gets the URL of the navigated page.\n   * @returns {string} The URL of the navigated page.\n   */\n  get url() {\n    return this._url\n  }\n\n  /**\n   * Gets the ID of the navigation operation.\n   * @returns {number} The ID of the navigation operation.\n   */\n  get navigationId() {\n    return this._navigationId\n  }\n}\n\n/**\n * Represents a print result.\n */\nclass PrintResult {\n  constructor(data) {\n    this._data = data\n  }\n\n  /**\n   * Gets the data associated with the print result.\n   * @returns {any} The data associated with the print result.\n   */\n  get data() {\n    return this._data\n  }\n}\n\n/**\n * initiate browsing context instance and return\n * @param driver\n * @param browsingContextId The browsing context of current window/tab\n * @param type \"window\" or \"tab\"\n * @param createParameters The parameters for creating a new browsing context\n * @returns {Promise<BrowsingContext>}\n */\nasync function getBrowsingContextInstance(\n  driver,\n  { browsingContextId = undefined, type = undefined, createParameters = undefined },\n) {\n  let instance = new BrowsingContext(driver)\n  await instance.init({ browsingContextId, type, createParameters })\n  return instance\n}\n\nmodule.exports = getBrowsingContextInstance\nmodule.exports.Locator = Locator\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAAEA,oBAAoB;EAAEC;AAAiB,CAAC,GAAGC,OAAO,CAAC,cAAc,CAAC;AAC1E,MAAM;EAAEC;AAAoB,CAAC,GAAGD,OAAO,CAAC,wBAAwB,CAAC;AACjE,MAAM;EAAEE,oBAAoB;EAAEC,cAAc;EAAEC;AAAY,CAAC,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;AACxF,MAAM;EAAEK;AAAW,CAAC,GAAGL,OAAO,CAAC,kBAAkB,CAAC;AAClD,MAAM;EAAEM;AAA4B,CAAC,GAAGN,OAAO,CAAC,+BAA+B,CAAC;AAChF,MAAM;EAAEO;AAAwB,CAAC,GAAGP,OAAO,CAAC,2BAA2B,CAAC;;AAExE;AACA;AACA;AACA;AACA,MAAMQ,OAAO,CAAC;EACZ,OAAOC,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC;IAC1BC,GAAG,EAAE,KAAK;IACVC,UAAU,EAAE,WAAW;IACvBC,KAAK,EAAE;EACT,CAAC,CAAC;EAEF,CAACC,IAAI;EACL,CAACC,KAAK;EACN,CAACC,UAAU;EACX,CAACC,SAAS;EACV,CAACC,QAAQ;EAETC,WAAWA,CAACL,IAAI,EAAEC,KAAK,EAAEC,UAAU,GAAGI,SAAS,EAAEH,SAAS,GAAGG,SAAS,EAAEF,QAAQ,GAAGE,SAAS,EAAE;IAC5F,IAAI,CAAC,CAACN,IAAI,GAAGA,IAAI;IACjB,IAAI,CAAC,CAACC,KAAK,GAAGA,KAAK;IACnB,IAAI,CAAC,CAACC,UAAU,GAAGA,UAAU;IAC7B,IAAI,CAAC,CAACC,SAAS,GAAGA,SAAS;IAC3B,IAAI,CAAC,CAACC,QAAQ,GAAGA,QAAQ;EAC3B;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,OAAOG,GAAGA,CAACN,KAAK,EAAE;IAChB,OAAO,IAAIR,OAAO,CAACA,OAAO,CAACC,IAAI,CAACG,GAAG,EAAEI,KAAK,CAAC;EAC7C;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,OAAOO,KAAKA,CAACP,KAAK,EAAE;IAClB,OAAO,IAAIR,OAAO,CAACA,OAAO,CAACC,IAAI,CAACK,KAAK,EAAEE,KAAK,CAAC;EAC/C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOQ,SAASA,CAACR,KAAK,EAAEC,UAAU,GAAGI,SAAS,EAAEH,SAAS,GAAGG,SAAS,EAAEF,QAAQ,GAAGE,SAAS,EAAE;IAC3F,OAAO,IAAIb,OAAO,CAACA,OAAO,CAACC,IAAI,CAACI,UAAU,EAAEG,KAAK,EAAEC,UAAU,EAAEC,SAAS,EAAEC,QAAQ,CAAC;EACrF;EAEAM,KAAKA,CAAA,EAAG;IACN,MAAMC,GAAG,GAAG,IAAIC,GAAG,CAAC,CAAC;IAErBD,GAAG,CAACE,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,CAACb,IAAI,CAACc,QAAQ,CAAC,CAAC,CAAC;IACtCH,GAAG,CAACE,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAACZ,KAAK,CAAC;IAC7BU,GAAG,CAACE,GAAG,CAAC,YAAY,EAAE,IAAI,CAAC,CAACX,UAAU,CAAC;IACvCS,GAAG,CAACE,GAAG,CAAC,WAAW,EAAE,IAAI,CAAC,CAACV,SAAS,CAAC;IACrCQ,GAAG,CAACE,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,CAACT,QAAQ,CAAC;IAEnC,OAAOO,GAAG;EACZ;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMI,eAAe,CAAC;EACpBV,WAAWA,CAACW,MAAM,EAAE;IAClB,IAAI,CAACC,OAAO,GAAGD,MAAM;EACvB;;EAEA;AACF;AACA;EACE,IAAIE,EAAEA,CAAA,EAAG;IACP,OAAO,IAAI,CAACC,GAAG;EACjB;EAEA,MAAMC,IAAIA,CAAC;IAAEC,iBAAiB,GAAGf,SAAS;IAAEN,IAAI,GAAGM,SAAS;IAAEgB,gBAAgB,GAAGhB;EAAU,CAAC,EAAE;IAC5F,IAAI,CAAC,CAAC,MAAM,IAAI,CAACW,OAAO,CAACM,eAAe,CAAC,CAAC,EAAEC,GAAG,CAAC,cAAc,CAAC,EAAE;MAC/D,MAAMC,KAAK,CAAC,+CAA+C,CAAC;IAC9D;IAEA,IAAIJ,iBAAiB,KAAKf,SAAS,IAAIN,IAAI,KAAKM,SAAS,IAAIgB,gBAAgB,KAAKhB,SAAS,EAAE;MAC3F,MAAMmB,KAAK,CAAC,uEAAuE,CAAC;IACtF;IAEA,IAAIzB,IAAI,KAAKM,SAAS,IAAIgB,gBAAgB,KAAKhB,SAAS,EAAE;MACxD,MAAMmB,KAAK,CAAC,6CAA6C,CAAC;IAC5D;IAEA,IAAIzB,IAAI,KAAKM,SAAS,IAAI,CAAC,CAAC,QAAQ,EAAE,KAAK,CAAC,CAACoB,QAAQ,CAAC1B,IAAI,CAAC,EAAE;MAC3D,MAAMyB,KAAK,CAAC,+CAA+CzB,IAAI,EAAE,CAAC;IACpE;IAEA,IAAI,CAAC2B,IAAI,GAAG,MAAM,IAAI,CAACV,OAAO,CAACW,OAAO,CAAC,CAAC;IACxC,IAAI,CAACT,GAAG,GACNE,iBAAiB,KAAKf,SAAS,GAC3B,CAAC,MAAM,IAAI,CAACuB,MAAM,CAAC7B,IAAI,EAAEsB,gBAAgB,CAAC,EAAE,QAAQ,CAAC,CAAC,SAAS,CAAC,GAChED,iBAAiB;EACzB;;EAEA;AACF;AACA;EACE,MAAMQ,MAAMA,CAAC7B,IAAI,EAAEsB,gBAAgB,GAAGhB,SAAS,EAAE;IAC/C,IAAIgB,gBAAgB,KAAKhB,SAAS,IAAK,CAACgB,gBAAgB,YAAa9B,uBAAuB,EAAE;MAC5F,MAAMiC,KAAK,CAAC,8DAA8DH,gBAAgB,EAAE,CAAC;IAC/F;IAEA,IAAIQ,UAAU,GAAG,IAAIlB,GAAG,CAAC,CAAC;IAC1BkB,UAAU,CAACjB,GAAG,CAAC,MAAM,EAAEb,IAAI,CAAC;IAE5B,IAAIsB,gBAAgB,KAAKhB,SAAS,EAAE;MAClCgB,gBAAgB,CAACS,KAAK,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC/B,KAAK,EAAEgC,GAAG,KAAK;QAC/CH,UAAU,CAACjB,GAAG,CAACoB,GAAG,EAAEhC,KAAK,CAAC;MAC5B,CAAC,CAAC;IACJ;IAEA,MAAMiC,MAAM,GAAG;MACbC,MAAM,EAAE,wBAAwB;MAChCD,MAAM,EAAEvC,MAAM,CAACyC,WAAW,CAACN,UAAU;IACvC,CAAC;IACD,OAAO,MAAM,IAAI,CAACH,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;EACrC;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMI,QAAQA,CAACC,GAAG,EAAEC,cAAc,GAAGlC,SAAS,EAAE;IAC9C,IAAIkC,cAAc,KAAKlC,SAAS,IAAI,CAAC,CAAC,MAAM,EAAE,aAAa,EAAE,UAAU,CAAC,CAACoB,QAAQ,CAACc,cAAc,CAAC,EAAE;MACjG,MAAMf,KAAK,CAAC,4EAA4Ee,cAAc,EAAE,CAAC;IAC3G;IAEA,MAAMN,MAAM,GAAG;MACbC,MAAM,EAAE,0BAA0B;MAClCD,MAAM,EAAE;QACNO,OAAO,EAAE,IAAI,CAACtB,GAAG;QACjBoB,GAAG,EAAEA,GAAG;QACRG,IAAI,EAAEF;MACR;IACF,CAAC;IACD,MAAMG,cAAc,GAAG,CAAC,MAAM,IAAI,CAAChB,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC,EAAE,QAAQ,CAAC;IAE/D,OAAO,IAAIU,cAAc,CAACD,cAAc,CAAC,KAAK,CAAC,EAAEA,cAAc,CAAC,YAAY,CAAC,CAAC;EAChF;;EAEA;AACF;AACA;AACA;EACE,MAAME,OAAOA,CAACzC,QAAQ,GAAGE,SAAS,EAAE;IAClC,MAAM4B,MAAM,GAAG;MACbC,MAAM,EAAE,yBAAyB;MACjCD,MAAM,EAAE;QACNY,IAAI,EAAE,IAAI,CAAC3B,GAAG;QACdf,QAAQ,EAAEA;MACZ;IACF,CAAC;IAED,IAAI2C,MAAM,GAAG,MAAM,IAAI,CAACpB,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;IACzC,IAAI,OAAO,IAAIa,MAAM,EAAE;MACrB,MAAMtB,KAAK,CAACsB,MAAM,CAAC,OAAO,CAAC,CAAC;IAC9B;IAEAA,MAAM,GAAGA,MAAM,CAAC,QAAQ,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;IACxC,OAAO,IAAI7D,mBAAmB,CAAC6D,MAAM,CAAC,SAAS,CAAC,EAAEA,MAAM,CAAC,KAAK,CAAC,EAAEA,MAAM,CAAC,UAAU,CAAC,EAAEA,MAAM,CAAC,QAAQ,CAAC,CAAC;EACxG;;EAEA;AACF;AACA;EACE,MAAMC,mBAAmBA,CAAA,EAAG;IAC1B,MAAMd,MAAM,GAAG;MACbC,MAAM,EAAE,yBAAyB;MACjCD,MAAM,EAAE,CAAC;IACX,CAAC;IAED,IAAIa,MAAM,GAAG,MAAM,IAAI,CAACpB,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;IACzC,IAAI,OAAO,IAAIa,MAAM,EAAE;MACrB,MAAMtB,KAAK,CAACsB,MAAM,CAAC,OAAO,CAAC,CAAC;IAC9B;IAEA,MAAME,QAAQ,GAAGF,MAAM,CAAC,QAAQ,CAAC,CAAC,UAAU,CAAC;IAC7C,MAAMG,gBAAgB,GAAGD,QAAQ,CAACtC,GAAG,CAAE8B,OAAO,IAAK;MACjD,OAAO,IAAIvD,mBAAmB,CAACuD,OAAO,CAAC,IAAI,CAAC,EAAEA,OAAO,CAAC,KAAK,CAAC,EAAEA,OAAO,CAAC,UAAU,CAAC,EAAEA,OAAO,CAAC,QAAQ,CAAC,CAAC;IACvG,CAAC,CAAC;IACF,OAAOS,gBAAgB;EACzB;;EAEA;AACF;AACA;AACA;EACE,MAAMC,KAAKA,CAAA,EAAG;IACZ,MAAMjB,MAAM,GAAG;MACbC,MAAM,EAAE,uBAAuB;MAC/BD,MAAM,EAAE;QACNO,OAAO,EAAE,IAAI,CAACtB;MAChB;IACF,CAAC;IACD,MAAM,IAAI,CAACQ,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;EAC9B;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMkB,SAASA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;IAC5B,IAAInB,MAAM,GAAG;MACXC,MAAM,EAAE,uBAAuB;MAC/B;MACAD,MAAM,EAAE;QACNO,OAAO,EAAE,IAAI,CAACtB,GAAG;QACjBmC,UAAU,EAAE,KAAK;QACjBC,MAAM,EAAE;UACNC,MAAM,EAAE,GAAG;UACXC,IAAI,EAAE,GAAG;UACTC,KAAK,EAAE,GAAG;UACVC,GAAG,EAAE;QACP,CAAC;QACDC,WAAW,EAAE,UAAU;QACvBC,IAAI,EAAE;UACJC,MAAM,EAAE,KAAK;UACbC,KAAK,EAAE;QACT,CAAC;QACDC,UAAU,EAAE,EAAE;QACdC,KAAK,EAAE,GAAG;QACVC,WAAW,EAAE;MACf;IACF,CAAC;;IAED;IACAhC,MAAM,CAACA,MAAM,GAAG,IAAI,CAACjB,OAAO,CAACkD,uBAAuB,CAACd,OAAO,EAAEnB,MAAM,CAACA,MAAM,CAAC;IAE5E,MAAMkC,QAAQ,GAAG,MAAM,IAAI,CAACzC,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;IAC7C,OAAO,IAAImC,WAAW,CAACD,QAAQ,CAACrB,MAAM,CAACuB,IAAI,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,iBAAiBA,CAACC,2BAA2B,GAAGlE,SAAS,EAAE;IAC/D,IACEkE,2BAA2B,KAAKlE,SAAS,IACzC,EAAEkE,2BAA2B,YAAYjF,2BAA2B,CAAC,EACrE;MACA,MAAM,IAAIR,oBAAoB,CAC5B,2DAA2DyF,2BAA2B,EACxF,CAAC;IACH;IAEA,MAAMC,gBAAgB,GAAG,IAAI7D,GAAG,CAAC,CAAC;IAClC6D,gBAAgB,CAAC5D,GAAG,CAAC,SAAS,EAAE,IAAI,CAACM,GAAG,CAAC;IACzC,IAAIqD,2BAA2B,KAAKlE,SAAS,EAAE;MAC7CkE,2BAA2B,CAACzC,KAAK,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC/B,KAAK,EAAEgC,GAAG,KAAK;QAC1DwC,gBAAgB,CAAC5D,GAAG,CAACoB,GAAG,EAAEhC,KAAK,CAAC;MAClC,CAAC,CAAC;IACJ;IAEA,IAAIiC,MAAM,GAAG;MACXC,MAAM,EAAE,mCAAmC;MAC3CD,MAAM,EAAEvC,MAAM,CAACyC,WAAW,CAACqC,gBAAgB;IAC7C,CAAC;IAED,MAAML,QAAQ,GAAG,MAAM,IAAI,CAACzC,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;IAC7C,IAAI,CAACwC,sBAAsB,CAACN,QAAQ,CAAC;IACrC,OAAOA,QAAQ,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC;EACnC;EAEA,MAAMO,oBAAoBA,CAACC,CAAC,EAAEC,CAAC,EAAEd,KAAK,EAAED,MAAM,EAAE;IAC9C,IAAI5B,MAAM,GAAG;MACXC,MAAM,EAAE,mCAAmC;MAC3CD,MAAM,EAAE;QACNO,OAAO,EAAE,IAAI,CAACtB,GAAG;QACjB2D,IAAI,EAAE;UACJ9E,IAAI,EAAE,KAAK;UACX4E,CAAC,EAAEA,CAAC;UACJC,CAAC,EAAEA,CAAC;UACJd,KAAK,EAAEA,KAAK;UACZD,MAAM,EAAEA;QACV;MACF;IACF,CAAC;IAED,MAAMM,QAAQ,GAAG,MAAM,IAAI,CAACzC,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;IAC7C,IAAI,CAACwC,sBAAsB,CAACN,QAAQ,CAAC;IACrC,OAAOA,QAAQ,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC;EACnC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMW,wBAAwBA,CAACC,QAAQ,EAAEC,MAAM,GAAG3E,SAAS,EAAE;IAC3D,IAAI4B,MAAM,GAAG;MACXC,MAAM,EAAE,mCAAmC;MAC3CD,MAAM,EAAE;QACNO,OAAO,EAAE,IAAI,CAACtB,GAAG;QACjB2D,IAAI,EAAE;UACJ9E,IAAI,EAAE,SAAS;UACfkF,OAAO,EAAE;YACPF,QAAQ,EAAEA,QAAQ;YAClBC,MAAM,EAAEA;UACV;QACF;MACF;IACF,CAAC;IAED,MAAMb,QAAQ,GAAG,MAAM,IAAI,CAACzC,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;IAC7C,IAAI,CAACwC,sBAAsB,CAACN,QAAQ,CAAC;IACrC,OAAOA,QAAQ,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC;EACnC;EAEAM,sBAAsBA,CAACN,QAAQ,EAAE;IAC/B,IAAI,OAAO,IAAIA,QAAQ,EAAE;MACvB,MAAM;QAAEe,KAAK;QAAEC;MAAI,CAAC,GAAGhB,QAAQ;MAE/B,QAAQe,KAAK;QACX,KAAK,kBAAkB;UACrB,MAAM,IAAIpG,oBAAoB,CAACqG,GAAG,CAAC;QAErC,KAAK,eAAe;UAClB,MAAM,IAAIpG,gBAAgB,CAACoG,GAAG,CAAC;MACnC;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMC,QAAQA,CAAA,EAAG;IACf,MAAMnD,MAAM,GAAG;MACbC,MAAM,EAAE,0BAA0B;MAClCD,MAAM,EAAE;QACNO,OAAO,EAAE,IAAI,CAACtB;MAChB;IACF,CAAC;IAED,IAAI4B,MAAM,GAAG,MAAM,IAAI,CAACpB,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;IACzC,IAAI,OAAO,IAAIa,MAAM,EAAE;MACrB,MAAMtB,KAAK,CAACsB,MAAM,CAAC,OAAO,CAAC,CAAC;IAC9B;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMuC,gBAAgBA,CAACC,MAAM,GAAGjF,SAAS,EAAEkF,QAAQ,GAAGlF,SAAS,EAAE;IAC/D,MAAM4B,MAAM,GAAG;MACbC,MAAM,EAAE,kCAAkC;MAC1CD,MAAM,EAAE;QACNO,OAAO,EAAE,IAAI,CAACtB,GAAG;QACjBoE,MAAM,EAAEA,MAAM;QACdC,QAAQ,EAAEA;MACZ;IACF,CAAC;IAED,IAAIzC,MAAM,GAAG,MAAM,IAAI,CAACpB,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;IACzC,IAAI,OAAO,IAAIa,MAAM,EAAE;MACrB,MAAMtB,KAAK,CAACsB,MAAM,CAAC,OAAO,CAAC,CAAC;IAC9B;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAM0C,MAAMA,CAACC,WAAW,GAAGpF,SAAS,EAAEkC,cAAc,GAAGlC,SAAS,EAAE;IAChE,IAAIkC,cAAc,KAAKlC,SAAS,IAAI,CAAC,CAAC,MAAM,EAAE,aAAa,EAAE,UAAU,CAAC,CAACoB,QAAQ,CAACc,cAAc,CAAC,EAAE;MACjG,MAAMf,KAAK,CAAC,4EAA4Ee,cAAc,EAAE,CAAC;IAC3G;IAEA,MAAMN,MAAM,GAAG;MACbC,MAAM,EAAE,wBAAwB;MAChCD,MAAM,EAAE;QACNO,OAAO,EAAE,IAAI,CAACtB,GAAG;QACjBuE,WAAW,EAAEA,WAAW;QACxBhD,IAAI,EAAEF;MACR;IACF,CAAC;IACD,MAAMG,cAAc,GAAG,CAAC,MAAM,IAAI,CAAChB,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC,EAAE,QAAQ,CAAC;IAE/D,OAAO,IAAIU,cAAc,CAACD,cAAc,CAAC,KAAK,CAAC,EAAEA,cAAc,CAAC,YAAY,CAAC,CAAC;EAChF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMgD,WAAWA,CAAC5B,KAAK,EAAED,MAAM,EAAE8B,gBAAgB,GAAGtF,SAAS,EAAE;IAC7D,MAAM4B,MAAM,GAAG;MACbC,MAAM,EAAE,6BAA6B;MACrCD,MAAM,EAAE;QACNO,OAAO,EAAE,IAAI,CAACtB,GAAG;QACjB0E,QAAQ,EAAE;UAAE9B,KAAK,EAAEA,KAAK;UAAED,MAAM,EAAEA;QAAO,CAAC;QAC1C8B,gBAAgB,EAAEA;MACpB;IACF,CAAC;IACD,IAAI7C,MAAM,GAAG,MAAM,IAAI,CAACpB,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;IACzC,IAAI,OAAO,IAAIa,MAAM,EAAE;MACrB,MAAMtB,KAAK,CAACsB,MAAM,CAAC,OAAO,CAAC,CAAC;IAC9B;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAM+C,eAAeA,CAACC,KAAK,EAAE;IAC3B,MAAM7D,MAAM,GAAG;MACbC,MAAM,EAAE,iCAAiC;MACzCD,MAAM,EAAE;QACNO,OAAO,EAAE,IAAI,CAACtB,GAAG;QACjB4E,KAAK,EAAEA;MACT;IACF,CAAC;IACD,MAAM,IAAI,CAACpE,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;EAC9B;;EAEA;AACF;AACA;AACA;EACE,MAAM8D,OAAOA,CAAA,EAAG;IACd,MAAM,IAAI,CAACF,eAAe,CAAC,CAAC,CAAC;EAC/B;;EAEA;AACF;AACA;AACA;EACE,MAAMG,IAAIA,CAAA,EAAG;IACX,MAAM,IAAI,CAACH,eAAe,CAAC,CAAC,CAAC,CAAC;EAChC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMI,WAAWA,CACfC,OAAO,EACPC,YAAY,GAAG9F,SAAS,EACxB+F,OAAO,GAAG/F,SAAS,EACnBgG,oBAAoB,GAAGhG,SAAS,EAChCiG,UAAU,GAAGjG,SAAS,EACtB;IACA,IAAI,EAAE6F,OAAO,YAAY1G,OAAO,CAAC,EAAE;MACjC,MAAMgC,KAAK,CAAC,uCAAuC0E,OAAO,EAAE,CAAC;IAC/D;IAEA,IAAIG,oBAAoB,KAAKhG,SAAS,IAAI,EAAEgG,oBAAoB,YAAYnH,oBAAoB,CAAC,EAAE;MACjG,MAAMsC,KAAK,CAAC,kDAAkD6E,oBAAoB,GAAG,CAAC;IACxF;IAEA,IAAIC,UAAU,KAAKjG,SAAS,IAAI,CAACkG,KAAK,CAACC,OAAO,CAACF,UAAU,CAAC,EAAE;MAC1D,MAAM9E,KAAK,CAAC,yDAAyD8E,UAAU,EAAE,CAAC;IACpF;IAEA,IAAIG,oBAAoB,GAAGpG,SAAS;IAEpC,IAAIiG,UAAU,KAAKjG,SAAS,IAAIkG,KAAK,CAACC,OAAO,CAACF,UAAU,CAAC,EAAE;MACzDG,oBAAoB,GAAG,EAAE;MACzBH,UAAU,CAACvE,OAAO,CAAE2E,IAAI,IAAK;QAC3B,IAAI,EAAEA,IAAI,YAAYvH,cAAc,CAAC,EAAE;UACrC,MAAMqC,KAAK,CAAC,8CAA8CkF,IAAI,EAAE,CAAC;QACnE,CAAC,MAAM;UACLD,oBAAoB,CAACE,IAAI,CAACD,IAAI,CAAC5E,KAAK,CAAC,CAAC,CAAC;QACzC;MACF,CAAC,CAAC;IACJ;IAEA,MAAMG,MAAM,GAAG;MACbC,MAAM,EAAE,6BAA6B;MACrCD,MAAM,EAAE;QACNO,OAAO,EAAE,IAAI,CAACtB,GAAG;QACjBgF,OAAO,EAAExG,MAAM,CAACyC,WAAW,CAAC+D,OAAO,CAACzF,KAAK,CAAC,CAAC,CAAC;QAC5C0F,YAAY,EAAEA,YAAY;QAC1BC,OAAO,EAAEA,OAAO;QAChBC,oBAAoB,EAAEA,oBAAoB;QAC1CC,UAAU,EAAEG;MACd;IACF,CAAC;IAED,IAAItC,QAAQ,GAAG,MAAM,IAAI,CAACzC,IAAI,CAACU,IAAI,CAACH,MAAM,CAAC;IAC3C,IAAI,OAAO,IAAIkC,QAAQ,EAAE;MACvB,MAAM3C,KAAK,CAAC2C,QAAQ,CAAC,OAAO,CAAC,CAAC;IAChC;IAEA,MAAMyC,KAAK,GAAGzC,QAAQ,CAACrB,MAAM,CAAC8D,KAAK;IACnC,MAAMC,YAAY,GAAG,EAAE;IAEvBD,KAAK,CAAC7E,OAAO,CAAE2E,IAAI,IAAK;MACtBG,YAAY,CAACF,IAAI,CAAC,IAAIvH,WAAW,CAACsH,IAAI,CAAC,CAAC;IAC1C,CAAC,CAAC;IACF,OAAOG,YAAY;EACrB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,UAAUA,CAACZ,OAAO,EAAEE,OAAO,GAAG/F,SAAS,EAAEgG,oBAAoB,GAAGhG,SAAS,EAAEiG,UAAU,GAAGjG,SAAS,EAAE;IACvG,MAAM0G,QAAQ,GAAG,MAAM,IAAI,CAACd,WAAW,CAACC,OAAO,EAAE,CAAC,EAAEE,OAAO,EAAEC,oBAAoB,EAAEC,UAAU,CAAC;IAC9F,OAAOS,QAAQ,CAAC,CAAC,CAAC;EACpB;EAEA,MAAMC,aAAaA,CAACd,OAAO,EAAE;IAC3B,MAAMa,QAAQ,GAAG,MAAM,IAAI,CAACd,WAAW,CAACC,OAAO,EAAE,CAAC,CAAC;IACnD,OAAO,IAAI7G,UAAU,CAAC,IAAI,CAAC2B,OAAO,EAAE+F,QAAQ,CAAC,CAAC,CAAC,CAAChC,QAAQ,CAAC;EAC3D;EAEA,MAAMkC,cAAcA,CAACf,OAAO,EAAE;IAC5B,MAAMa,QAAQ,GAAG,MAAM,IAAI,CAACd,WAAW,CAACC,OAAO,CAAC;IAEhD,IAAIgB,WAAW,GAAG,EAAE;IACpBH,QAAQ,CAAChF,OAAO,CAAEkD,OAAO,IAAK;MAC5BiC,WAAW,CAACP,IAAI,CAAC,IAAItH,UAAU,CAAC,IAAI,CAAC2B,OAAO,EAAEiE,OAAO,CAACF,QAAQ,CAAC,CAAC;IAClE,CAAC,CAAC;IACF,OAAOmC,WAAW;EACpB;AACF;;AAEA;AACA;AACA;AACA,MAAMvE,cAAc,CAAC;EACnBvC,WAAWA,CAACkC,GAAG,EAAE6E,YAAY,EAAE;IAC7B,IAAI,CAACC,IAAI,GAAG9E,GAAG;IACf,IAAI,CAAC+E,aAAa,GAAGF,YAAY;EACnC;;EAEA;AACF;AACA;AACA;EACE,IAAI7E,GAAGA,CAAA,EAAG;IACR,OAAO,IAAI,CAAC8E,IAAI;EAClB;;EAEA;AACF;AACA;AACA;EACE,IAAID,YAAYA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACE,aAAa;EAC3B;AACF;;AAEA;AACA;AACA;AACA,MAAMjD,WAAW,CAAC;EAChBhE,WAAWA,CAACiE,IAAI,EAAE;IAChB,IAAI,CAACiD,KAAK,GAAGjD,IAAI;EACnB;;EAEA;AACF;AACA;AACA;EACE,IAAIA,IAAIA,CAAA,EAAG;IACT,OAAO,IAAI,CAACiD,KAAK;EACnB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeC,0BAA0BA,CACvCxG,MAAM,EACN;EAAEK,iBAAiB,GAAGf,SAAS;EAAEN,IAAI,GAAGM,SAAS;EAAEgB,gBAAgB,GAAGhB;AAAU,CAAC,EACjF;EACA,IAAImH,QAAQ,GAAG,IAAI1G,eAAe,CAACC,MAAM,CAAC;EAC1C,MAAMyG,QAAQ,CAACrG,IAAI,CAAC;IAAEC,iBAAiB;IAAErB,IAAI;IAAEsB;EAAiB,CAAC,CAAC;EAClE,OAAOmG,QAAQ;AACjB;AAEAC,MAAM,CAACC,OAAO,GAAGH,0BAA0B;AAC3CE,MAAM,CAACC,OAAO,CAAClI,OAAO,GAAGA,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}