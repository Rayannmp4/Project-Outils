{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/*\n * Licensed to the Software Freedom Conservancy (SFC) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The SFC licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict';\n\nconst {\n  By\n} = require('./by');\nconst error = require('./error');\n\n/**\n * ISelect interface makes a protocol for all kind of select elements (standard html and custom\n * model)\n *\n * @interface\n */\n// eslint-disable-next-line no-unused-vars\nclass ISelect {\n  /**\n   * @return {!Promise<boolean>} Whether this select element supports selecting multiple options at the same time? This\n   * is done by checking the value of the \"multiple\" attribute.\n   */\n  isMultiple() {}\n\n  /**\n   * @return {!Promise<!Array<!WebElement>>} All options belonging to this select tag\n   */\n  getOptions() {}\n\n  /**\n   * @return {!Promise<!Array<!WebElement>>} All selected options belonging to this select tag\n   */\n  getAllSelectedOptions() {}\n\n  /**\n   * @return {!Promise<!WebElement>} The first selected option in this select tag (or the currently selected option in a\n   * normal select)\n   */\n  getFirstSelectedOption() {}\n\n  /**\n   * Select all options that display text matching the argument. That is, when given \"Bar\" this\n   * would select an option like:\n   *\n   * &lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n   *\n   * @param {string} text The visible text to match against\n   * @return {Promise<void>}\n   */\n  selectByVisibleText(text) {} // eslint-disable-line\n\n  /**\n   * Select all options that have a value matching the argument. That is, when given \"foo\" this\n   * would select an option like:\n   *\n   * &lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n   *\n   * @param {string} value The value to match against\n   * @return {Promise<void>}\n   */\n  selectByValue(value) {} // eslint-disable-line\n\n  /**\n   * Select the option at the given index. This is done by examining the \"index\" attribute of an\n   * element, and not merely by counting.\n   *\n   * @param {Number} index The option at this index will be selected\n   * @return {Promise<void>}\n   */\n  selectByIndex(index) {} // eslint-disable-line\n\n  /**\n   * Clear all selected entries. This is only valid when the SELECT supports multiple selections.\n   *\n   * @return {Promise<void>}\n   */\n  deselectAll() {}\n\n  /**\n   * Deselect all options that display text matching the argument. That is, when given \"Bar\" this\n   * would deselect an option like:\n   *\n   * &lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n   *\n   * @param {string} text The visible text to match against\n   * @return {Promise<void>}\n   */\n  deselectByVisibleText(text) {} // eslint-disable-line\n\n  /**\n   * Deselect all options that have a value matching the argument. That is, when given \"foo\" this\n   * would deselect an option like:\n   *\n   * @param {string} value The value to match against\n   * @return {Promise<void>}\n   */\n  deselectByValue(value) {} // eslint-disable-line\n\n  /**\n   * Deselect the option at the given index. This is done by examining the \"index\" attribute of an\n   * element, and not merely by counting.\n   *\n   * @param {Number} index The option at this index will be deselected\n   * @return {Promise<void>}\n   */\n  deselectByIndex(index) {} // eslint-disable-line\n}\n\n/**\n * @implements ISelect\n */\nclass Select {\n  /**\n   * Create an Select Element\n   * @param {WebElement} element Select WebElement.\n   */\n  constructor(element) {\n    if (element === null) {\n      throw new Error(`Element must not be null. Please provide a valid <select> element.`);\n    }\n    this.element = element;\n    this.element.getAttribute('tagName').then(function (tagName) {\n      if (tagName.toLowerCase() !== 'select') {\n        throw new Error(`Select only works on <select> elements`);\n      }\n    });\n    this.element.getAttribute('multiple').then(multiple => {\n      this.multiple = multiple !== null && multiple !== 'false';\n    });\n  }\n\n  /**\n   *\n   * Select option with specified index.\n   *\n   * <example>\n   <select id=\"selectbox\">\n   <option value=\"1\">Option 1</option>\n   <option value=\"2\">Option 2</option>\n   <option value=\"3\">Option 3</option>\n   </select>\n   const selectBox = await driver.findElement(By.id(\"selectbox\"));\n   await selectObject.selectByIndex(1);\n   * </example>\n   *\n   * @param index\n   */\n  async selectByIndex(index) {\n    if (index < 0) {\n      throw new Error('Index needs to be 0 or any other positive number');\n    }\n    let options = await this.element.findElements(By.tagName('option'));\n    if (options.length === 0) {\n      throw new Error(\"Select element doesn't contain any option element\");\n    }\n    if (options.length - 1 < index) {\n      throw new Error(`Option with index \"${index}\" not found. Select element only contains ${options.length - 1} option elements`);\n    }\n    for (let option of options) {\n      if ((await option.getAttribute('index')) === index.toString()) {\n        await this.setSelected(option);\n      }\n    }\n  }\n\n  /**\n   *\n   * Select option by specific value.\n   *\n   * <example>\n   <select id=\"selectbox\">\n   <option value=\"1\">Option 1</option>\n   <option value=\"2\">Option 2</option>\n   <option value=\"3\">Option 3</option>\n   </select>\n   const selectBox = await driver.findElement(By.id(\"selectbox\"));\n   await selectObject.selectByVisibleText(\"Option 2\");\n   * </example>\n   *\n   *\n   * @param {string} value value of option element to be selected\n   */\n  async selectByValue(value) {\n    let matched = false;\n    let isMulti = await this.isMultiple();\n    let options = await this.element.findElements(By.xpath('.//option[@value = ' + escapeQuotes(value) + ']'));\n    for (let option of options) {\n      await this.setSelected(option);\n      if (!isMulti) {\n        return;\n      }\n      matched = true;\n    }\n    if (!matched) {\n      throw new Error(`Cannot locate option with value: ${value}`);\n    }\n  }\n\n  /**\n   *\n   * Select option with displayed text matching the argument.\n   *\n   * <example>\n   <select id=\"selectbox\">\n   <option value=\"1\">Option 1</option>\n   <option value=\"2\">Option 2</option>\n   <option value=\"3\">Option 3</option>\n   </select>\n   const selectBox = await driver.findElement(By.id(\"selectbox\"));\n   await selectObject.selectByVisibleText(\"Option 2\");\n   * </example>\n   *\n   * @param {String|Number} text       text of option element to get selected\n   *\n   */\n  async selectByVisibleText(text) {\n    text = typeof text === 'number' ? text.toString() : text;\n    const xpath = './/option[normalize-space(.) = ' + escapeQuotes(text) + ']';\n    const options = await this.element.findElements(By.xpath(xpath));\n    for (let option of options) {\n      await this.setSelected(option);\n      if (!(await this.isMultiple())) {\n        return;\n      }\n    }\n    let matched = Array.isArray(options) && options.length > 0;\n    if (!matched && text.includes(' ')) {\n      const subStringWithoutSpace = getLongestSubstringWithoutSpace(text);\n      let candidates;\n      if ('' === subStringWithoutSpace) {\n        candidates = await this.element.findElements(By.tagName('option'));\n      } else {\n        const xpath = './/option[contains(., ' + escapeQuotes(subStringWithoutSpace) + ')]';\n        candidates = await this.element.findElements(By.xpath(xpath));\n      }\n      const trimmed = text.trim();\n      for (let option of candidates) {\n        const optionText = await option.getText();\n        if (trimmed === optionText.trim()) {\n          await this.setSelected(option);\n          if (!(await this.isMultiple())) {\n            return;\n          }\n          matched = true;\n        }\n      }\n    }\n    if (!matched) {\n      throw new Error(`Cannot locate option with text: ${text}`);\n    }\n  }\n\n  /**\n   * Returns a list of all options belonging to this select tag\n   * @returns {!Promise<!Array<!WebElement>>}\n   */\n  async getOptions() {\n    return await this.element.findElements({\n      tagName: 'option'\n    });\n  }\n\n  /**\n   * Returns a boolean value if the select tag is multiple\n   * @returns {Promise<boolean>}\n   */\n  async isMultiple() {\n    return this.multiple;\n  }\n\n  /**\n   * Returns a list of all selected options belonging to this select tag\n   *\n   * @returns {Promise<void>}\n   */\n  async getAllSelectedOptions() {\n    const opts = await this.getOptions();\n    const results = [];\n    for (let options of opts) {\n      if (await options.isSelected()) {\n        results.push(options);\n      }\n    }\n    return results;\n  }\n\n  /**\n   * Returns first Selected Option\n   * @returns {Promise<Element>}\n   */\n  async getFirstSelectedOption() {\n    return (await this.getAllSelectedOptions())[0];\n  }\n\n  /**\n   * Deselects all selected options\n   * @returns {Promise<void>}\n   */\n  async deselectAll() {\n    if (!this.isMultiple()) {\n      throw new Error('You may only deselect all options of a multi-select');\n    }\n    const options = await this.getOptions();\n    for (let option of options) {\n      if (await option.isSelected()) {\n        await option.click();\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {string|Number}text text of option to deselect\n   * @returns {Promise<void>}\n   */\n  async deselectByVisibleText(text) {\n    if (!(await this.isMultiple())) {\n      throw new Error('You may only deselect options of a multi-select');\n    }\n\n    /**\n     * convert value into string\n     */\n    text = typeof text === 'number' ? text.toString() : text;\n    const optionElement = await this.element.findElement(By.xpath('.//option[normalize-space(.) = ' + escapeQuotes(text) + ']'));\n    if (await optionElement.isSelected()) {\n      await optionElement.click();\n    }\n  }\n\n  /**\n   *\n   * @param {Number} index       index of option element to deselect\n   * Deselect the option at the given index.\n   * This is done by examining the \"index\"\n   * attribute of an element, and not merely by counting.\n   * @returns {Promise<void>}\n   */\n  async deselectByIndex(index) {\n    if (!(await this.isMultiple())) {\n      throw new Error('You may only deselect options of a multi-select');\n    }\n    if (index < 0) {\n      throw new Error('Index needs to be 0 or any other positive number');\n    }\n    let options = await this.element.findElements(By.tagName('option'));\n    if (options.length === 0) {\n      throw new Error(\"Select element doesn't contain any option element\");\n    }\n    if (options.length - 1 < index) {\n      throw new Error(`Option with index \"${index}\" not found. Select element only contains ${options.length - 1} option elements`);\n    }\n    for (let option of options) {\n      if ((await option.getAttribute('index')) === index.toString()) {\n        if (await option.isSelected()) {\n          await option.click();\n        }\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {String} value value of an option to deselect\n   * @returns {Promise<void>}\n   */\n  async deselectByValue(value) {\n    if (!(await this.isMultiple())) {\n      throw new Error('You may only deselect options of a multi-select');\n    }\n    let matched = false;\n    let options = await this.element.findElements(By.xpath('.//option[@value = ' + escapeQuotes(value) + ']'));\n    if (options.length === 0) {\n      throw new Error(`Cannot locate option with value: ${value}`);\n    }\n    for (let option of options) {\n      if (await option.isSelected()) {\n        await option.click();\n      }\n      matched = true;\n    }\n    if (!matched) {\n      throw new Error(`Cannot locate option with value: ${value}`);\n    }\n  }\n  async setSelected(option) {\n    if (!(await option.isSelected())) {\n      if (!(await option.isEnabled())) {\n        throw new error.UnsupportedOperationError(`You may not select a disabled option`);\n      }\n      await option.click();\n    }\n  }\n}\nfunction escapeQuotes(toEscape) {\n  if (toEscape.includes(`\"`) && toEscape.includes(`'`)) {\n    const quoteIsLast = toEscape.lastIndexOf(`\"`) === toEscape.length - 1;\n    const substrings = toEscape.split(`\"`);\n\n    // Remove the last element if it's an empty string\n    if (substrings[substrings.length - 1] === '') {\n      substrings.pop();\n    }\n    let result = 'concat(';\n    for (let i = 0; i < substrings.length; i++) {\n      result += `\"${substrings[i]}\"`;\n      result += i === substrings.length - 1 ? quoteIsLast ? `, '\"')` : `)` : `, '\"', `;\n    }\n    return result;\n  }\n  if (toEscape.includes('\"')) {\n    return `'${toEscape}'`;\n  }\n\n  // Otherwise return the quoted string\n  return `\"${toEscape}\"`;\n}\nfunction getLongestSubstringWithoutSpace(text) {\n  let words = text.split(' ');\n  let longestString = '';\n  for (let word of words) {\n    if (word.length > longestString.length) {\n      longestString = word;\n    }\n  }\n  return longestString;\n}\nmodule.exports = {\n  Select,\n  escapeQuotes\n};","map":{"version":3,"names":["By","require","error","ISelect","isMultiple","getOptions","getAllSelectedOptions","getFirstSelectedOption","selectByVisibleText","text","selectByValue","value","selectByIndex","index","deselectAll","deselectByVisibleText","deselectByValue","deselectByIndex","Select","constructor","element","Error","getAttribute","then","tagName","toLowerCase","multiple","options","findElements","length","option","toString","setSelected","matched","isMulti","xpath","escapeQuotes","Array","isArray","includes","subStringWithoutSpace","getLongestSubstringWithoutSpace","candidates","trimmed","trim","optionText","getText","opts","results","isSelected","push","click","optionElement","findElement","isEnabled","UnsupportedOperationError","toEscape","quoteIsLast","lastIndexOf","substrings","split","pop","result","i","words","longestString","word","module","exports"],"sources":["C:/Users/rayan/Documents/GitHub/Project-Outils/node_modules/selenium-webdriver/lib/select.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n/*\n * Licensed to the Software Freedom Conservancy (SFC) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The SFC licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict'\n\nconst { By } = require('./by')\nconst error = require('./error')\n\n/**\n * ISelect interface makes a protocol for all kind of select elements (standard html and custom\n * model)\n *\n * @interface\n */\n// eslint-disable-next-line no-unused-vars\nclass ISelect {\n  /**\n   * @return {!Promise<boolean>} Whether this select element supports selecting multiple options at the same time? This\n   * is done by checking the value of the \"multiple\" attribute.\n   */\n  isMultiple() {}\n\n  /**\n   * @return {!Promise<!Array<!WebElement>>} All options belonging to this select tag\n   */\n  getOptions() {}\n\n  /**\n   * @return {!Promise<!Array<!WebElement>>} All selected options belonging to this select tag\n   */\n  getAllSelectedOptions() {}\n\n  /**\n   * @return {!Promise<!WebElement>} The first selected option in this select tag (or the currently selected option in a\n   * normal select)\n   */\n  getFirstSelectedOption() {}\n\n  /**\n   * Select all options that display text matching the argument. That is, when given \"Bar\" this\n   * would select an option like:\n   *\n   * &lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n   *\n   * @param {string} text The visible text to match against\n   * @return {Promise<void>}\n   */\n  selectByVisibleText(text) {} // eslint-disable-line\n\n  /**\n   * Select all options that have a value matching the argument. That is, when given \"foo\" this\n   * would select an option like:\n   *\n   * &lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n   *\n   * @param {string} value The value to match against\n   * @return {Promise<void>}\n   */\n  selectByValue(value) {} // eslint-disable-line\n\n  /**\n   * Select the option at the given index. This is done by examining the \"index\" attribute of an\n   * element, and not merely by counting.\n   *\n   * @param {Number} index The option at this index will be selected\n   * @return {Promise<void>}\n   */\n  selectByIndex(index) {} // eslint-disable-line\n\n  /**\n   * Clear all selected entries. This is only valid when the SELECT supports multiple selections.\n   *\n   * @return {Promise<void>}\n   */\n  deselectAll() {}\n\n  /**\n   * Deselect all options that display text matching the argument. That is, when given \"Bar\" this\n   * would deselect an option like:\n   *\n   * &lt;option value=\"foo\"&gt;Bar&lt;/option&gt;\n   *\n   * @param {string} text The visible text to match against\n   * @return {Promise<void>}\n   */\n  deselectByVisibleText(text) {} // eslint-disable-line\n\n  /**\n   * Deselect all options that have a value matching the argument. That is, when given \"foo\" this\n   * would deselect an option like:\n   *\n   * @param {string} value The value to match against\n   * @return {Promise<void>}\n   */\n  deselectByValue(value) {} // eslint-disable-line\n\n  /**\n   * Deselect the option at the given index. This is done by examining the \"index\" attribute of an\n   * element, and not merely by counting.\n   *\n   * @param {Number} index The option at this index will be deselected\n   * @return {Promise<void>}\n   */\n  deselectByIndex(index) {} // eslint-disable-line\n}\n\n/**\n * @implements ISelect\n */\nclass Select {\n  /**\n   * Create an Select Element\n   * @param {WebElement} element Select WebElement.\n   */\n  constructor(element) {\n    if (element === null) {\n      throw new Error(`Element must not be null. Please provide a valid <select> element.`)\n    }\n\n    this.element = element\n\n    this.element.getAttribute('tagName').then(function (tagName) {\n      if (tagName.toLowerCase() !== 'select') {\n        throw new Error(`Select only works on <select> elements`)\n      }\n    })\n\n    this.element.getAttribute('multiple').then((multiple) => {\n      this.multiple = multiple !== null && multiple !== 'false'\n    })\n  }\n\n  /**\n   *\n   * Select option with specified index.\n   *\n   * <example>\n   <select id=\"selectbox\">\n   <option value=\"1\">Option 1</option>\n   <option value=\"2\">Option 2</option>\n   <option value=\"3\">Option 3</option>\n   </select>\n   const selectBox = await driver.findElement(By.id(\"selectbox\"));\n   await selectObject.selectByIndex(1);\n   * </example>\n   *\n   * @param index\n   */\n  async selectByIndex(index) {\n    if (index < 0) {\n      throw new Error('Index needs to be 0 or any other positive number')\n    }\n\n    let options = await this.element.findElements(By.tagName('option'))\n\n    if (options.length === 0) {\n      throw new Error(\"Select element doesn't contain any option element\")\n    }\n\n    if (options.length - 1 < index) {\n      throw new Error(\n        `Option with index \"${index}\" not found. Select element only contains ${options.length - 1} option elements`,\n      )\n    }\n\n    for (let option of options) {\n      if ((await option.getAttribute('index')) === index.toString()) {\n        await this.setSelected(option)\n      }\n    }\n  }\n\n  /**\n   *\n   * Select option by specific value.\n   *\n   * <example>\n   <select id=\"selectbox\">\n   <option value=\"1\">Option 1</option>\n   <option value=\"2\">Option 2</option>\n   <option value=\"3\">Option 3</option>\n   </select>\n   const selectBox = await driver.findElement(By.id(\"selectbox\"));\n   await selectObject.selectByVisibleText(\"Option 2\");\n   * </example>\n   *\n   *\n   * @param {string} value value of option element to be selected\n   */\n  async selectByValue(value) {\n    let matched = false\n    let isMulti = await this.isMultiple()\n\n    let options = await this.element.findElements(By.xpath('.//option[@value = ' + escapeQuotes(value) + ']'))\n\n    for (let option of options) {\n      await this.setSelected(option)\n\n      if (!isMulti) {\n        return\n      }\n      matched = true\n    }\n\n    if (!matched) {\n      throw new Error(`Cannot locate option with value: ${value}`)\n    }\n  }\n\n  /**\n   *\n   * Select option with displayed text matching the argument.\n   *\n   * <example>\n   <select id=\"selectbox\">\n   <option value=\"1\">Option 1</option>\n   <option value=\"2\">Option 2</option>\n   <option value=\"3\">Option 3</option>\n   </select>\n   const selectBox = await driver.findElement(By.id(\"selectbox\"));\n   await selectObject.selectByVisibleText(\"Option 2\");\n   * </example>\n   *\n   * @param {String|Number} text       text of option element to get selected\n   *\n   */\n  async selectByVisibleText(text) {\n    text = typeof text === 'number' ? text.toString() : text\n\n    const xpath = './/option[normalize-space(.) = ' + escapeQuotes(text) + ']'\n\n    const options = await this.element.findElements(By.xpath(xpath))\n\n    for (let option of options) {\n      await this.setSelected(option)\n      if (!(await this.isMultiple())) {\n        return\n      }\n    }\n\n    let matched = Array.isArray(options) && options.length > 0\n\n    if (!matched && text.includes(' ')) {\n      const subStringWithoutSpace = getLongestSubstringWithoutSpace(text)\n      let candidates\n      if ('' === subStringWithoutSpace) {\n        candidates = await this.element.findElements(By.tagName('option'))\n      } else {\n        const xpath = './/option[contains(., ' + escapeQuotes(subStringWithoutSpace) + ')]'\n        candidates = await this.element.findElements(By.xpath(xpath))\n      }\n\n      const trimmed = text.trim()\n\n      for (let option of candidates) {\n        const optionText = await option.getText()\n        if (trimmed === optionText.trim()) {\n          await this.setSelected(option)\n          if (!(await this.isMultiple())) {\n            return\n          }\n          matched = true\n        }\n      }\n    }\n\n    if (!matched) {\n      throw new Error(`Cannot locate option with text: ${text}`)\n    }\n  }\n\n  /**\n   * Returns a list of all options belonging to this select tag\n   * @returns {!Promise<!Array<!WebElement>>}\n   */\n  async getOptions() {\n    return await this.element.findElements({ tagName: 'option' })\n  }\n\n  /**\n   * Returns a boolean value if the select tag is multiple\n   * @returns {Promise<boolean>}\n   */\n  async isMultiple() {\n    return this.multiple\n  }\n\n  /**\n   * Returns a list of all selected options belonging to this select tag\n   *\n   * @returns {Promise<void>}\n   */\n  async getAllSelectedOptions() {\n    const opts = await this.getOptions()\n    const results = []\n    for (let options of opts) {\n      if (await options.isSelected()) {\n        results.push(options)\n      }\n    }\n    return results\n  }\n\n  /**\n   * Returns first Selected Option\n   * @returns {Promise<Element>}\n   */\n  async getFirstSelectedOption() {\n    return (await this.getAllSelectedOptions())[0]\n  }\n\n  /**\n   * Deselects all selected options\n   * @returns {Promise<void>}\n   */\n  async deselectAll() {\n    if (!this.isMultiple()) {\n      throw new Error('You may only deselect all options of a multi-select')\n    }\n\n    const options = await this.getOptions()\n\n    for (let option of options) {\n      if (await option.isSelected()) {\n        await option.click()\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {string|Number}text text of option to deselect\n   * @returns {Promise<void>}\n   */\n  async deselectByVisibleText(text) {\n    if (!(await this.isMultiple())) {\n      throw new Error('You may only deselect options of a multi-select')\n    }\n\n    /**\n     * convert value into string\n     */\n    text = typeof text === 'number' ? text.toString() : text\n\n    const optionElement = await this.element.findElement(\n      By.xpath('.//option[normalize-space(.) = ' + escapeQuotes(text) + ']'),\n    )\n    if (await optionElement.isSelected()) {\n      await optionElement.click()\n    }\n  }\n\n  /**\n   *\n   * @param {Number} index       index of option element to deselect\n   * Deselect the option at the given index.\n   * This is done by examining the \"index\"\n   * attribute of an element, and not merely by counting.\n   * @returns {Promise<void>}\n   */\n  async deselectByIndex(index) {\n    if (!(await this.isMultiple())) {\n      throw new Error('You may only deselect options of a multi-select')\n    }\n\n    if (index < 0) {\n      throw new Error('Index needs to be 0 or any other positive number')\n    }\n\n    let options = await this.element.findElements(By.tagName('option'))\n\n    if (options.length === 0) {\n      throw new Error(\"Select element doesn't contain any option element\")\n    }\n\n    if (options.length - 1 < index) {\n      throw new Error(\n        `Option with index \"${index}\" not found. Select element only contains ${options.length - 1} option elements`,\n      )\n    }\n\n    for (let option of options) {\n      if ((await option.getAttribute('index')) === index.toString()) {\n        if (await option.isSelected()) {\n          await option.click()\n        }\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {String} value value of an option to deselect\n   * @returns {Promise<void>}\n   */\n  async deselectByValue(value) {\n    if (!(await this.isMultiple())) {\n      throw new Error('You may only deselect options of a multi-select')\n    }\n\n    let matched = false\n\n    let options = await this.element.findElements(By.xpath('.//option[@value = ' + escapeQuotes(value) + ']'))\n\n    if (options.length === 0) {\n      throw new Error(`Cannot locate option with value: ${value}`)\n    }\n\n    for (let option of options) {\n      if (await option.isSelected()) {\n        await option.click()\n      }\n      matched = true\n    }\n\n    if (!matched) {\n      throw new Error(`Cannot locate option with value: ${value}`)\n    }\n  }\n\n  async setSelected(option) {\n    if (!(await option.isSelected())) {\n      if (!(await option.isEnabled())) {\n        throw new error.UnsupportedOperationError(`You may not select a disabled option`)\n      }\n      await option.click()\n    }\n  }\n}\n\nfunction escapeQuotes(toEscape) {\n  if (toEscape.includes(`\"`) && toEscape.includes(`'`)) {\n    const quoteIsLast = toEscape.lastIndexOf(`\"`) === toEscape.length - 1\n    const substrings = toEscape.split(`\"`)\n\n    // Remove the last element if it's an empty string\n    if (substrings[substrings.length - 1] === '') {\n      substrings.pop()\n    }\n\n    let result = 'concat('\n\n    for (let i = 0; i < substrings.length; i++) {\n      result += `\"${substrings[i]}\"`\n      result += i === substrings.length - 1 ? (quoteIsLast ? `, '\"')` : `)`) : `, '\"', `\n    }\n    return result\n  }\n\n  if (toEscape.includes('\"')) {\n    return `'${toEscape}'`\n  }\n\n  // Otherwise return the quoted string\n  return `\"${toEscape}\"`\n}\n\nfunction getLongestSubstringWithoutSpace(text) {\n  let words = text.split(' ')\n  let longestString = ''\n  for (let word of words) {\n    if (word.length > longestString.length) {\n      longestString = word\n    }\n  }\n  return longestString\n}\n\nmodule.exports = { Select, escapeQuotes }\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAM;EAAEA;AAAG,CAAC,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC9B,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAS,CAAC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,OAAO,CAAC;EACZ;AACF;AACA;AACA;EACEC,UAAUA,CAAA,EAAG,CAAC;;EAEd;AACF;AACA;EACEC,UAAUA,CAAA,EAAG,CAAC;;EAEd;AACF;AACA;EACEC,qBAAqBA,CAAA,EAAG,CAAC;;EAEzB;AACF;AACA;AACA;EACEC,sBAAsBA,CAAA,EAAG,CAAC;;EAE1B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,mBAAmBA,CAACC,IAAI,EAAE,CAAC,CAAC,CAAC;;EAE7B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,aAAaA,CAACC,KAAK,EAAE,CAAC,CAAC,CAAC;;EAExB;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,aAAaA,CAACC,KAAK,EAAE,CAAC,CAAC,CAAC;;EAExB;AACF;AACA;AACA;AACA;EACEC,WAAWA,CAAA,EAAG,CAAC;;EAEf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,qBAAqBA,CAACN,IAAI,EAAE,CAAC,CAAC,CAAC;;EAE/B;AACF;AACA;AACA;AACA;AACA;AACA;EACEO,eAAeA,CAACL,KAAK,EAAE,CAAC,CAAC,CAAC;;EAE1B;AACF;AACA;AACA;AACA;AACA;AACA;EACEM,eAAeA,CAACJ,KAAK,EAAE,CAAC,CAAC,CAAC;AAC5B;;AAEA;AACA;AACA;AACA,MAAMK,MAAM,CAAC;EACX;AACF;AACA;AACA;EACEC,WAAWA,CAACC,OAAO,EAAE;IACnB,IAAIA,OAAO,KAA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}