{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst {\n  FilterBy\n} = require('./filterBy');\nconst {\n  ConsoleLogEntry,\n  JavascriptLogEntry,\n  GenericLogEntry\n} = require('./logEntries');\nconst LOG = {\n  TYPE_CONSOLE: 'console',\n  TYPE_JS_LOGS: 'javascript',\n  TYPE_JS_EXCEPTION: 'javascriptException',\n  TYPE_LOGS: 'logs',\n  TYPE_CONSOLE_FILTER: 'console_filter',\n  TYPE_JS_LOGS_FILTER: 'javascript_filter',\n  TYPE_JS_EXCEPTION_FILTER: 'javascriptException_filter',\n  TYPE_LOGS_FILTER: 'logs_filter'\n};\nclass LogInspector {\n  bidi;\n  ws;\n  #callbackId = 0;\n  constructor(driver, browsingContextIds) {\n    this._driver = driver;\n    this._browsingContextIds = browsingContextIds;\n    this.listener = new Map();\n    this.listener.set(LOG.TYPE_CONSOLE, new Map());\n    this.listener.set(LOG.TYPE_JS_LOGS, new Map());\n    this.listener.set(LOG.TYPE_JS_EXCEPTION, new Map());\n    this.listener.set(LOG.TYPE_LOGS, new Map());\n    this.listener.set(LOG.TYPE_CONSOLE_FILTER, new Map());\n    this.listener.set(LOG.TYPE_JS_LOGS_FILTER, new Map());\n    this.listener.set(LOG.TYPE_JS_EXCEPTION_FILTER, new Map());\n    this.listener.set(LOG.TYPE_LOGS_FILTER, new Map());\n  }\n\n  /**\n   * Subscribe to log event\n   * @returns {Promise<void>}\n   */\n  async init() {\n    this.bidi = await this._driver.getBidi();\n    await this.bidi.subscribe('log.entryAdded', this._browsingContextIds);\n  }\n  addCallback(eventType, callback) {\n    const id = ++this.#callbackId;\n    const eventCallbackMap = this.listener.get(eventType);\n    eventCallbackMap.set(id, callback);\n    return id;\n  }\n  removeCallback(id) {\n    let hasId = false;\n    for (const [, callbacks] of this.listener) {\n      if (callbacks.has(id)) {\n        callbacks.delete(id);\n        hasId = true;\n      }\n    }\n    if (!hasId) {\n      throw Error(`Callback with id ${id} not found`);\n    }\n  }\n  invokeCallbacks(eventType, data) {\n    const callbacks = this.listener.get(eventType);\n    if (callbacks) {\n      for (const [, callback] of callbacks) {\n        callback(data);\n      }\n    }\n  }\n  invokeCallbacksWithFilter(eventType, data, filterLevel) {\n    const callbacks = this.listener.get(eventType);\n    if (callbacks) {\n      for (const [, value] of callbacks) {\n        const callback = value.callback;\n        const filter = value.filter;\n        if (filterLevel === filter.getLevel()) {\n          callback(data);\n        }\n      }\n    }\n  }\n\n  /**\n   * Listen to Console logs\n   * @param callback\n   * @param filterBy\n   * @returns {Promise<number>}\n   */\n  async onConsoleEntry(callback, filterBy = undefined) {\n    if (filterBy !== undefined && !(filterBy instanceof FilterBy)) {\n      throw Error(`Pass valid FilterBy object. Received: ${filterBy}`);\n    }\n    let id;\n    if (filterBy !== undefined) {\n      id = this.addCallback(LOG.TYPE_CONSOLE_FILTER, {\n        callback: callback,\n        filter: filterBy\n      });\n    } else {\n      id = this.addCallback(LOG.TYPE_CONSOLE, callback);\n    }\n    this.ws = await this.bidi.socket;\n    this.ws.on('message', event => {\n      const {\n        params\n      } = JSON.parse(Buffer.from(event.toString()));\n      if (params?.type === LOG.TYPE_CONSOLE) {\n        let consoleEntry = new ConsoleLogEntry(params.level, params.source, params.text, params.timestamp, params.type, params.method, params.args, params.stackTrace);\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            this.invokeCallbacksWithFilter(LOG.TYPE_CONSOLE_FILTER, consoleEntry, filterBy.getLevel());\n          }\n          return;\n        }\n        this.invokeCallbacks(LOG.TYPE_CONSOLE, consoleEntry);\n      }\n    });\n    return id;\n  }\n\n  /**\n   * Listen to JS logs\n   * @param callback\n   * @param filterBy\n   * @returns {Promise<number>}\n   */\n  async onJavascriptLog(callback, filterBy = undefined) {\n    if (filterBy !== undefined && !(filterBy instanceof FilterBy)) {\n      throw Error(`Pass valid FilterBy object. Received: ${filterBy}`);\n    }\n    let id;\n    if (filterBy !== undefined) {\n      id = this.addCallback(LOG.TYPE_JS_LOGS_FILTER, {\n        callback: callback,\n        filter: filterBy\n      });\n    } else {\n      id = this.addCallback(LOG.TYPE_JS_LOGS, callback);\n    }\n    this.ws = await this.bidi.socket;\n    this.ws.on('message', event => {\n      const {\n        params\n      } = JSON.parse(Buffer.from(event.toString()));\n      if (params?.type === LOG.TYPE_JS_LOGS) {\n        let jsEntry = new JavascriptLogEntry(params.level, params.source, params.text, params.timestamp, params.type, params.stackTrace);\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            this.invokeCallbacksWithFilter(LOG.TYPE_JS_LOGS_FILTER, jsEntry, filterBy.getLevel());\n          }\n          return;\n        }\n        this.invokeCallbacks(LOG.TYPE_JS_LOGS, jsEntry);\n      }\n    });\n    return id;\n  }\n\n  /**\n   * Listen to JS Exceptions\n   * @param callback\n   * @returns {Promise<number>}\n   */\n  async onJavascriptException(callback) {\n    const id = this.addCallback(LOG.TYPE_JS_EXCEPTION, callback);\n    this.ws = await this.bidi.socket;\n    this.ws.on('message', event => {\n      const {\n        params\n      } = JSON.parse(Buffer.from(event.toString()));\n      if (params?.type === 'javascript' && params?.level === 'error') {\n        let jsErrorEntry = new JavascriptLogEntry(params.level, params.source, params.text, params.timestamp, params.type, params.stackTrace);\n        this.invokeCallbacks(LOG.TYPE_JS_EXCEPTION, jsErrorEntry);\n      }\n    });\n    return id;\n  }\n\n  /**\n   * Listen to any logs\n   * @param callback\n   * @param filterBy\n   * @returns {Promise<number>}\n   */\n  async onLog(callback, filterBy = undefined) {\n    if (filterBy !== undefined && !(filterBy instanceof FilterBy)) {\n      throw Error(`Pass valid FilterBy object. Received: ${filterBy}`);\n    }\n    let id;\n    if (filterBy !== undefined) {\n      id = this.addCallback(LOG.TYPE_LOGS_FILTER, {\n        callback: callback,\n        filter: filterBy\n      });\n    } else {\n      id = this.addCallback(LOG.TYPE_LOGS, callback);\n    }\n    this.ws = await this.bidi.socket;\n    this.ws.on('message', event => {\n      const {\n        params\n      } = JSON.parse(Buffer.from(event.toString()));\n      if (params?.type === 'javascript') {\n        let jsEntry = new JavascriptLogEntry(params.level, params.source, params.text, params.timestamp, params.type, params.stackTrace);\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            callback(jsEntry);\n          }\n          return;\n        }\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            {\n              this.invokeCallbacksWithFilter(LOG.TYPE_LOGS_FILTER, jsEntry, filterBy.getLevel());\n            }\n            return;\n          }\n        }\n        this.invokeCallbacks(LOG.TYPE_LOGS, jsEntry);\n        return;\n      }\n      if (params?.type === 'console') {\n        let consoleEntry = new ConsoleLogEntry(params.level, params.source, params.text, params.timestamp, params.type, params.method, params.args, params.stackTrace);\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            this.invokeCallbacksWithFilter(LOG.TYPE_LOGS_FILTER, consoleEntry, filterBy.getLevel());\n          }\n          return;\n        }\n        this.invokeCallbacks(LOG.TYPE_LOGS, consoleEntry);\n        return;\n      }\n      if (params !== undefined && !['console', 'javascript'].includes(params?.type)) {\n        let genericEntry = new GenericLogEntry(params.level, params.source, params.text, params.timestamp, params.type, params.stackTrace);\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            {\n              this.invokeCallbacksWithFilter(LOG.TYPE_LOGS_FILTER, genericEntry, filterBy.getLevel());\n            }\n            return;\n          }\n        }\n        this.invokeCallbacks(LOG.TYPE_LOGS, genericEntry);\n        return;\n      }\n    });\n    return id;\n  }\n\n  /**\n   * Unsubscribe to log event\n   * @returns {Promise<void>}\n   */\n  async close() {\n    if (this._browsingContextIds !== null && this._browsingContextIds !== undefined && this._browsingContextIds.length > 0) {\n      await this.bidi.unsubscribe('log.entryAdded', this._browsingContextIds);\n    } else {\n      await this.bidi.unsubscribe('log.entryAdded');\n    }\n  }\n}\n\n/**\n * initiate inspector instance and return\n * @param driver\n * @param browsingContextIds\n * @returns {Promise<LogInspector>}\n */\nasync function getLogInspectorInstance(driver, browsingContextIds) {\n  let instance = new LogInspector(driver, browsingContextIds);\n  await instance.init();\n  return instance;\n}\n\n/**\n * API\n * @type {function(*, *): Promise<LogInspector>}\n */\nmodule.exports = getLogInspectorInstance;","map":{"version":3,"names":["FilterBy","require","ConsoleLogEntry","JavascriptLogEntry","GenericLogEntry","LOG","TYPE_CONSOLE","TYPE_JS_LOGS","TYPE_JS_EXCEPTION","TYPE_LOGS","TYPE_CONSOLE_FILTER","TYPE_JS_LOGS_FILTER","TYPE_JS_EXCEPTION_FILTER","TYPE_LOGS_FILTER","LogInspector","bidi","ws","callbackId","constructor","driver","browsingContextIds","_driver","_browsingContextIds","listener","Map","set","init","getBidi","subscribe","addCallback","eventType","callback","id","eventCallbackMap","get","removeCallback","hasId","callbacks","has","delete","Error","invokeCallbacks","data","invokeCallbacksWithFilter","filterLevel","value","filter","getLevel","onConsoleEntry","filterBy","undefined","socket","on","event","params","JSON","parse","Buffer","from","toString","type","consoleEntry","level","source","text","timestamp","method","args","stackTrace","onJavascriptLog","jsEntry","onJavascriptException","jsErrorEntry","onLog","includes","genericEntry","close","length","unsubscribe","getLogInspectorInstance","instance","module","exports"],"sources":["C:/Users/rayan/Documents/GitHub/Project-Outils/node_modules/selenium-webdriver/bidi/logInspector.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst { FilterBy } = require('./filterBy')\nconst { ConsoleLogEntry, JavascriptLogEntry, GenericLogEntry } = require('./logEntries')\n\nconst LOG = {\n  TYPE_CONSOLE: 'console',\n  TYPE_JS_LOGS: 'javascript',\n  TYPE_JS_EXCEPTION: 'javascriptException',\n  TYPE_LOGS: 'logs',\n  TYPE_CONSOLE_FILTER: 'console_filter',\n  TYPE_JS_LOGS_FILTER: 'javascript_filter',\n  TYPE_JS_EXCEPTION_FILTER: 'javascriptException_filter',\n  TYPE_LOGS_FILTER: 'logs_filter',\n}\n\nclass LogInspector {\n  bidi\n  ws\n  #callbackId = 0\n\n  constructor(driver, browsingContextIds) {\n    this._driver = driver\n    this._browsingContextIds = browsingContextIds\n    this.listener = new Map()\n    this.listener.set(LOG.TYPE_CONSOLE, new Map())\n    this.listener.set(LOG.TYPE_JS_LOGS, new Map())\n    this.listener.set(LOG.TYPE_JS_EXCEPTION, new Map())\n    this.listener.set(LOG.TYPE_LOGS, new Map())\n    this.listener.set(LOG.TYPE_CONSOLE_FILTER, new Map())\n    this.listener.set(LOG.TYPE_JS_LOGS_FILTER, new Map())\n    this.listener.set(LOG.TYPE_JS_EXCEPTION_FILTER, new Map())\n    this.listener.set(LOG.TYPE_LOGS_FILTER, new Map())\n  }\n\n  /**\n   * Subscribe to log event\n   * @returns {Promise<void>}\n   */\n  async init() {\n    this.bidi = await this._driver.getBidi()\n    await this.bidi.subscribe('log.entryAdded', this._browsingContextIds)\n  }\n\n  addCallback(eventType, callback) {\n    const id = ++this.#callbackId\n\n    const eventCallbackMap = this.listener.get(eventType)\n    eventCallbackMap.set(id, callback)\n    return id\n  }\n\n  removeCallback(id) {\n    let hasId = false\n    for (const [, callbacks] of this.listener) {\n      if (callbacks.has(id)) {\n        callbacks.delete(id)\n        hasId = true\n      }\n    }\n\n    if (!hasId) {\n      throw Error(`Callback with id ${id} not found`)\n    }\n  }\n\n  invokeCallbacks(eventType, data) {\n    const callbacks = this.listener.get(eventType)\n    if (callbacks) {\n      for (const [, callback] of callbacks) {\n        callback(data)\n      }\n    }\n  }\n\n  invokeCallbacksWithFilter(eventType, data, filterLevel) {\n    const callbacks = this.listener.get(eventType)\n    if (callbacks) {\n      for (const [, value] of callbacks) {\n        const callback = value.callback\n        const filter = value.filter\n        if (filterLevel === filter.getLevel()) {\n          callback(data)\n        }\n      }\n    }\n  }\n\n  /**\n   * Listen to Console logs\n   * @param callback\n   * @param filterBy\n   * @returns {Promise<number>}\n   */\n  async onConsoleEntry(callback, filterBy = undefined) {\n    if (filterBy !== undefined && !(filterBy instanceof FilterBy)) {\n      throw Error(`Pass valid FilterBy object. Received: ${filterBy}`)\n    }\n\n    let id\n\n    if (filterBy !== undefined) {\n      id = this.addCallback(LOG.TYPE_CONSOLE_FILTER, { callback: callback, filter: filterBy })\n    } else {\n      id = this.addCallback(LOG.TYPE_CONSOLE, callback)\n    }\n\n    this.ws = await this.bidi.socket\n\n    this.ws.on('message', (event) => {\n      const { params } = JSON.parse(Buffer.from(event.toString()))\n\n      if (params?.type === LOG.TYPE_CONSOLE) {\n        let consoleEntry = new ConsoleLogEntry(\n          params.level,\n          params.source,\n          params.text,\n          params.timestamp,\n          params.type,\n          params.method,\n          params.args,\n          params.stackTrace,\n        )\n\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            this.invokeCallbacksWithFilter(LOG.TYPE_CONSOLE_FILTER, consoleEntry, filterBy.getLevel())\n          }\n          return\n        }\n\n        this.invokeCallbacks(LOG.TYPE_CONSOLE, consoleEntry)\n      }\n    })\n\n    return id\n  }\n\n  /**\n   * Listen to JS logs\n   * @param callback\n   * @param filterBy\n   * @returns {Promise<number>}\n   */\n  async onJavascriptLog(callback, filterBy = undefined) {\n    if (filterBy !== undefined && !(filterBy instanceof FilterBy)) {\n      throw Error(`Pass valid FilterBy object. Received: ${filterBy}`)\n    }\n\n    let id\n\n    if (filterBy !== undefined) {\n      id = this.addCallback(LOG.TYPE_JS_LOGS_FILTER, { callback: callback, filter: filterBy })\n    } else {\n      id = this.addCallback(LOG.TYPE_JS_LOGS, callback)\n    }\n\n    this.ws = await this.bidi.socket\n\n    this.ws.on('message', (event) => {\n      const { params } = JSON.parse(Buffer.from(event.toString()))\n\n      if (params?.type === LOG.TYPE_JS_LOGS) {\n        let jsEntry = new JavascriptLogEntry(\n          params.level,\n          params.source,\n          params.text,\n          params.timestamp,\n          params.type,\n          params.stackTrace,\n        )\n\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            this.invokeCallbacksWithFilter(LOG.TYPE_JS_LOGS_FILTER, jsEntry, filterBy.getLevel())\n          }\n          return\n        }\n\n        this.invokeCallbacks(LOG.TYPE_JS_LOGS, jsEntry)\n      }\n    })\n\n    return id\n  }\n\n  /**\n   * Listen to JS Exceptions\n   * @param callback\n   * @returns {Promise<number>}\n   */\n  async onJavascriptException(callback) {\n    const id = this.addCallback(LOG.TYPE_JS_EXCEPTION, callback)\n    this.ws = await this.bidi.socket\n\n    this.ws.on('message', (event) => {\n      const { params } = JSON.parse(Buffer.from(event.toString()))\n      if (params?.type === 'javascript' && params?.level === 'error') {\n        let jsErrorEntry = new JavascriptLogEntry(\n          params.level,\n          params.source,\n          params.text,\n          params.timestamp,\n          params.type,\n          params.stackTrace,\n        )\n\n        this.invokeCallbacks(LOG.TYPE_JS_EXCEPTION, jsErrorEntry)\n      }\n    })\n\n    return id\n  }\n\n  /**\n   * Listen to any logs\n   * @param callback\n   * @param filterBy\n   * @returns {Promise<number>}\n   */\n  async onLog(callback, filterBy = undefined) {\n    if (filterBy !== undefined && !(filterBy instanceof FilterBy)) {\n      throw Error(`Pass valid FilterBy object. Received: ${filterBy}`)\n    }\n\n    let id\n    if (filterBy !== undefined) {\n      id = this.addCallback(LOG.TYPE_LOGS_FILTER, { callback: callback, filter: filterBy })\n    } else {\n      id = this.addCallback(LOG.TYPE_LOGS, callback)\n    }\n\n    this.ws = await this.bidi.socket\n\n    this.ws.on('message', (event) => {\n      const { params } = JSON.parse(Buffer.from(event.toString()))\n      if (params?.type === 'javascript') {\n        let jsEntry = new JavascriptLogEntry(\n          params.level,\n          params.source,\n          params.text,\n          params.timestamp,\n          params.type,\n          params.stackTrace,\n        )\n\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            callback(jsEntry)\n          }\n          return\n        }\n\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            {\n              this.invokeCallbacksWithFilter(LOG.TYPE_LOGS_FILTER, jsEntry, filterBy.getLevel())\n            }\n            return\n          }\n        }\n\n        this.invokeCallbacks(LOG.TYPE_LOGS, jsEntry)\n        return\n      }\n\n      if (params?.type === 'console') {\n        let consoleEntry = new ConsoleLogEntry(\n          params.level,\n          params.source,\n          params.text,\n          params.timestamp,\n          params.type,\n          params.method,\n          params.args,\n          params.stackTrace,\n        )\n\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            this.invokeCallbacksWithFilter(LOG.TYPE_LOGS_FILTER, consoleEntry, filterBy.getLevel())\n          }\n          return\n        }\n\n        this.invokeCallbacks(LOG.TYPE_LOGS, consoleEntry)\n        return\n      }\n\n      if (params !== undefined && !['console', 'javascript'].includes(params?.type)) {\n        let genericEntry = new GenericLogEntry(\n          params.level,\n          params.source,\n          params.text,\n          params.timestamp,\n          params.type,\n          params.stackTrace,\n        )\n\n        if (filterBy !== undefined) {\n          if (params?.level === filterBy.getLevel()) {\n            {\n              this.invokeCallbacksWithFilter(LOG.TYPE_LOGS_FILTER, genericEntry, filterBy.getLevel())\n            }\n            return\n          }\n        }\n\n        this.invokeCallbacks(LOG.TYPE_LOGS, genericEntry)\n        return\n      }\n    })\n\n    return id\n  }\n\n  /**\n   * Unsubscribe to log event\n   * @returns {Promise<void>}\n   */\n  async close() {\n    if (\n      this._browsingContextIds !== null &&\n      this._browsingContextIds !== undefined &&\n      this._browsingContextIds.length > 0\n    ) {\n      await this.bidi.unsubscribe('log.entryAdded', this._browsingContextIds)\n    } else {\n      await this.bidi.unsubscribe('log.entryAdded')\n    }\n  }\n}\n\n/**\n * initiate inspector instance and return\n * @param driver\n * @param browsingContextIds\n * @returns {Promise<LogInspector>}\n */\nasync function getLogInspectorInstance(driver, browsingContextIds) {\n  let instance = new LogInspector(driver, browsingContextIds)\n  await instance.init()\n  return instance\n}\n\n/**\n * API\n * @type {function(*, *): Promise<LogInspector>}\n */\nmodule.exports = getLogInspectorInstance\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAAEA;AAAS,CAAC,GAAGC,OAAO,CAAC,YAAY,CAAC;AAC1C,MAAM;EAAEC,eAAe;EAAEC,kBAAkB;EAAEC;AAAgB,CAAC,GAAGH,OAAO,CAAC,cAAc,CAAC;AAExF,MAAMI,GAAG,GAAG;EACVC,YAAY,EAAE,SAAS;EACvBC,YAAY,EAAE,YAAY;EAC1BC,iBAAiB,EAAE,qBAAqB;EACxCC,SAAS,EAAE,MAAM;EACjBC,mBAAmB,EAAE,gBAAgB;EACrCC,mBAAmB,EAAE,mBAAmB;EACxCC,wBAAwB,EAAE,4BAA4B;EACtDC,gBAAgB,EAAE;AACpB,CAAC;AAED,MAAMC,YAAY,CAAC;EACjBC,IAAI;EACJC,EAAE;EACF,CAACC,UAAU,GAAG,CAAC;EAEfC,WAAWA,CAACC,MAAM,EAAEC,kBAAkB,EAAE;IACtC,IAAI,CAACC,OAAO,GAAGF,MAAM;IACrB,IAAI,CAACG,mBAAmB,GAAGF,kBAAkB;IAC7C,IAAI,CAACG,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC;IACzB,IAAI,CAACD,QAAQ,CAACE,GAAG,CAACpB,GAAG,CAACC,YAAY,EAAE,IAAIkB,GAAG,CAAC,CAAC,CAAC;IAC9C,IAAI,CAACD,QAAQ,CAACE,GAAG,CAACpB,GAAG,CAACE,YAAY,EAAE,IAAIiB,GAAG,CAAC,CAAC,CAAC;IAC9C,IAAI,CAACD,QAAQ,CAACE,GAAG,CAACpB,GAAG,CAACG,iBAAiB,EAAE,IAAIgB,GAAG,CAAC,CAAC,CAAC;IACnD,IAAI,CAACD,QAAQ,CAACE,GAAG,CAACpB,GAAG,CAACI,SAAS,EAAE,IAAIe,GAAG,CAAC,CAAC,CAAC;IAC3C,IAAI,CAACD,QAAQ,CAACE,GAAG,CAACpB,GAAG,CAACK,mBAAmB,EAAE,IAAIc,GAAG,CAAC,CAAC,CAAC;IACrD,IAAI,CAACD,QAAQ,CAACE,GAAG,CAACpB,GAAG,CAACM,mBAAmB,EAAE,IAAIa,GAAG,CAAC,CAAC,CAAC;IACrD,IAAI,CAACD,QAAQ,CAACE,GAAG,CAACpB,GAAG,CAACO,wBAAwB,EAAE,IAAIY,GAAG,CAAC,CAAC,CAAC;IAC1D,IAAI,CAACD,QAAQ,CAACE,GAAG,CAACpB,GAAG,CAACQ,gBAAgB,EAAE,IAAIW,GAAG,CAAC,CAAC,CAAC;EACpD;;EAEA;AACF;AACA;AACA;EACE,MAAME,IAAIA,CAAA,EAAG;IACX,IAAI,CAACX,IAAI,GAAG,MAAM,IAAI,CAACM,OAAO,CAACM,OAAO,CAAC,CAAC;IACxC,MAAM,IAAI,CAACZ,IAAI,CAACa,SAAS,CAAC,gBAAgB,EAAE,IAAI,CAACN,mBAAmB,CAAC;EACvE;EAEAO,WAAWA,CAACC,SAAS,EAAEC,QAAQ,EAAE;IAC/B,MAAMC,EAAE,GAAG,EAAE,IAAI,CAAC,CAACf,UAAU;IAE7B,MAAMgB,gBAAgB,GAAG,IAAI,CAACV,QAAQ,CAACW,GAAG,CAACJ,SAAS,CAAC;IACrDG,gBAAgB,CAACR,GAAG,CAACO,EAAE,EAAED,QAAQ,CAAC;IAClC,OAAOC,EAAE;EACX;EAEAG,cAAcA,CAACH,EAAE,EAAE;IACjB,IAAII,KAAK,GAAG,KAAK;IACjB,KAAK,MAAM,GAAGC,SAAS,CAAC,IAAI,IAAI,CAACd,QAAQ,EAAE;MACzC,IAAIc,SAAS,CAACC,GAAG,CAACN,EAAE,CAAC,EAAE;QACrBK,SAAS,CAACE,MAAM,CAACP,EAAE,CAAC;QACpBI,KAAK,GAAG,IAAI;MACd;IACF;IAEA,IAAI,CAACA,KAAK,EAAE;MACV,MAAMI,KAAK,CAAC,oBAAoBR,EAAE,YAAY,CAAC;IACjD;EACF;EAEAS,eAAeA,CAACX,SAAS,EAAEY,IAAI,EAAE;IAC/B,MAAML,SAAS,GAAG,IAAI,CAACd,QAAQ,CAACW,GAAG,CAACJ,SAAS,CAAC;IAC9C,IAAIO,SAAS,EAAE;MACb,KAAK,MAAM,GAAGN,QAAQ,CAAC,IAAIM,SAAS,EAAE;QACpCN,QAAQ,CAACW,IAAI,CAAC;MAChB;IACF;EACF;EAEAC,yBAAyBA,CAACb,SAAS,EAAEY,IAAI,EAAEE,WAAW,EAAE;IACtD,MAAMP,SAAS,GAAG,IAAI,CAACd,QAAQ,CAACW,GAAG,CAACJ,SAAS,CAAC;IAC9C,IAAIO,SAAS,EAAE;MACb,KAAK,MAAM,GAAGQ,KAAK,CAAC,IAAIR,SAAS,EAAE;QACjC,MAAMN,QAAQ,GAAGc,KAAK,CAACd,QAAQ;QAC/B,MAAMe,MAAM,GAAGD,KAAK,CAACC,MAAM;QAC3B,IAAIF,WAAW,KAAKE,MAAM,CAACC,QAAQ,CAAC,CAAC,EAAE;UACrChB,QAAQ,CAACW,IAAI,CAAC;QAChB;MACF;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMM,cAAcA,CAACjB,QAAQ,EAAEkB,QAAQ,GAAGC,SAAS,EAAE;IACnD,IAAID,QAAQ,KAAKC,SAAS,IAAI,EAAED,QAAQ,YAAYjD,QAAQ,CAAC,EAAE;MAC7D,MAAMwC,KAAK,CAAC,yCAAyCS,QAAQ,EAAE,CAAC;IAClE;IAEA,IAAIjB,EAAE;IAEN,IAAIiB,QAAQ,KAAKC,SAAS,EAAE;MAC1BlB,EAAE,GAAG,IAAI,CAACH,WAAW,CAACxB,GAAG,CAACK,mBAAmB,EAAE;QAAEqB,QAAQ,EAAEA,QAAQ;QAAEe,MAAM,EAAEG;MAAS,CAAC,CAAC;IAC1F,CAAC,MAAM;MACLjB,EAAE,GAAG,IAAI,CAACH,WAAW,CAACxB,GAAG,CAACC,YAAY,EAAEyB,QAAQ,CAAC;IACnD;IAEA,IAAI,CAACf,EAAE,GAAG,MAAM,IAAI,CAACD,IAAI,CAACoC,MAAM;IAEhC,IAAI,CAACnC,EAAE,CAACoC,EAAE,CAAC,SAAS,EAAGC,KAAK,IAAK;MAC/B,MAAM;QAAEC;MAAO,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACC,MAAM,CAACC,IAAI,CAACL,KAAK,CAACM,QAAQ,CAAC,CAAC,CAAC,CAAC;MAE5D,IAAIL,MAAM,EAAEM,IAAI,KAAKvD,GAAG,CAACC,YAAY,EAAE;QACrC,IAAIuD,YAAY,GAAG,IAAI3D,eAAe,CACpCoD,MAAM,CAACQ,KAAK,EACZR,MAAM,CAACS,MAAM,EACbT,MAAM,CAACU,IAAI,EACXV,MAAM,CAACW,SAAS,EAChBX,MAAM,CAACM,IAAI,EACXN,MAAM,CAACY,MAAM,EACbZ,MAAM,CAACa,IAAI,EACXb,MAAM,CAACc,UACT,CAAC;QAED,IAAInB,QAAQ,KAAKC,SAAS,EAAE;UAC1B,IAAII,MAAM,EAAEQ,KAAK,KAAKb,QAAQ,CAACF,QAAQ,CAAC,CAAC,EAAE;YACzC,IAAI,CAACJ,yBAAyB,CAACtC,GAAG,CAACK,mBAAmB,EAAEmD,YAAY,EAAEZ,QAAQ,CAACF,QAAQ,CAAC,CAAC,CAAC;UAC5F;UACA;QACF;QAEA,IAAI,CAACN,eAAe,CAACpC,GAAG,CAACC,YAAY,EAAEuD,YAAY,CAAC;MACtD;IACF,CAAC,CAAC;IAEF,OAAO7B,EAAE;EACX;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMqC,eAAeA,CAACtC,QAAQ,EAAEkB,QAAQ,GAAGC,SAAS,EAAE;IACpD,IAAID,QAAQ,KAAKC,SAAS,IAAI,EAAED,QAAQ,YAAYjD,QAAQ,CAAC,EAAE;MAC7D,MAAMwC,KAAK,CAAC,yCAAyCS,QAAQ,EAAE,CAAC;IAClE;IAEA,IAAIjB,EAAE;IAEN,IAAIiB,QAAQ,KAAKC,SAAS,EAAE;MAC1BlB,EAAE,GAAG,IAAI,CAACH,WAAW,CAACxB,GAAG,CAACM,mBAAmB,EAAE;QAAEoB,QAAQ,EAAEA,QAAQ;QAAEe,MAAM,EAAEG;MAAS,CAAC,CAAC;IAC1F,CAAC,MAAM;MACLjB,EAAE,GAAG,IAAI,CAACH,WAAW,CAACxB,GAAG,CAACE,YAAY,EAAEwB,QAAQ,CAAC;IACnD;IAEA,IAAI,CAACf,EAAE,GAAG,MAAM,IAAI,CAACD,IAAI,CAACoC,MAAM;IAEhC,IAAI,CAACnC,EAAE,CAACoC,EAAE,CAAC,SAAS,EAAGC,KAAK,IAAK;MAC/B,MAAM;QAAEC;MAAO,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACC,MAAM,CAACC,IAAI,CAACL,KAAK,CAACM,QAAQ,CAAC,CAAC,CAAC,CAAC;MAE5D,IAAIL,MAAM,EAAEM,IAAI,KAAKvD,GAAG,CAACE,YAAY,EAAE;QACrC,IAAI+D,OAAO,GAAG,IAAInE,kBAAkB,CAClCmD,MAAM,CAACQ,KAAK,EACZR,MAAM,CAACS,MAAM,EACbT,MAAM,CAACU,IAAI,EACXV,MAAM,CAACW,SAAS,EAChBX,MAAM,CAACM,IAAI,EACXN,MAAM,CAACc,UACT,CAAC;QAED,IAAInB,QAAQ,KAAKC,SAAS,EAAE;UAC1B,IAAII,MAAM,EAAEQ,KAAK,KAAKb,QAAQ,CAACF,QAAQ,CAAC,CAAC,EAAE;YACzC,IAAI,CAACJ,yBAAyB,CAACtC,GAAG,CAACM,mBAAmB,EAAE2D,OAAO,EAAErB,QAAQ,CAACF,QAAQ,CAAC,CAAC,CAAC;UACvF;UACA;QACF;QAEA,IAAI,CAACN,eAAe,CAACpC,GAAG,CAACE,YAAY,EAAE+D,OAAO,CAAC;MACjD;IACF,CAAC,CAAC;IAEF,OAAOtC,EAAE;EACX;;EAEA;AACF;AACA;AACA;AACA;EACE,MAAMuC,qBAAqBA,CAACxC,QAAQ,EAAE;IACpC,MAAMC,EAAE,GAAG,IAAI,CAACH,WAAW,CAACxB,GAAG,CAACG,iBAAiB,EAAEuB,QAAQ,CAAC;IAC5D,IAAI,CAACf,EAAE,GAAG,MAAM,IAAI,CAACD,IAAI,CAACoC,MAAM;IAEhC,IAAI,CAACnC,EAAE,CAACoC,EAAE,CAAC,SAAS,EAAGC,KAAK,IAAK;MAC/B,MAAM;QAAEC;MAAO,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACC,MAAM,CAACC,IAAI,CAACL,KAAK,CAACM,QAAQ,CAAC,CAAC,CAAC,CAAC;MAC5D,IAAIL,MAAM,EAAEM,IAAI,KAAK,YAAY,IAAIN,MAAM,EAAEQ,KAAK,KAAK,OAAO,EAAE;QAC9D,IAAIU,YAAY,GAAG,IAAIrE,kBAAkB,CACvCmD,MAAM,CAACQ,KAAK,EACZR,MAAM,CAACS,MAAM,EACbT,MAAM,CAACU,IAAI,EACXV,MAAM,CAACW,SAAS,EAChBX,MAAM,CAACM,IAAI,EACXN,MAAM,CAACc,UACT,CAAC;QAED,IAAI,CAAC3B,eAAe,CAACpC,GAAG,CAACG,iBAAiB,EAAEgE,YAAY,CAAC;MAC3D;IACF,CAAC,CAAC;IAEF,OAAOxC,EAAE;EACX;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,MAAMyC,KAAKA,CAAC1C,QAAQ,EAAEkB,QAAQ,GAAGC,SAAS,EAAE;IAC1C,IAAID,QAAQ,KAAKC,SAAS,IAAI,EAAED,QAAQ,YAAYjD,QAAQ,CAAC,EAAE;MAC7D,MAAMwC,KAAK,CAAC,yCAAyCS,QAAQ,EAAE,CAAC;IAClE;IAEA,IAAIjB,EAAE;IACN,IAAIiB,QAAQ,KAAKC,SAAS,EAAE;MAC1BlB,EAAE,GAAG,IAAI,CAACH,WAAW,CAACxB,GAAG,CAACQ,gBAAgB,EAAE;QAAEkB,QAAQ,EAAEA,QAAQ;QAAEe,MAAM,EAAEG;MAAS,CAAC,CAAC;IACvF,CAAC,MAAM;MACLjB,EAAE,GAAG,IAAI,CAACH,WAAW,CAACxB,GAAG,CAACI,SAAS,EAAEsB,QAAQ,CAAC;IAChD;IAEA,IAAI,CAACf,EAAE,GAAG,MAAM,IAAI,CAACD,IAAI,CAACoC,MAAM;IAEhC,IAAI,CAACnC,EAAE,CAACoC,EAAE,CAAC,SAAS,EAAGC,KAAK,IAAK;MAC/B,MAAM;QAAEC;MAAO,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACC,MAAM,CAACC,IAAI,CAACL,KAAK,CAACM,QAAQ,CAAC,CAAC,CAAC,CAAC;MAC5D,IAAIL,MAAM,EAAEM,IAAI,KAAK,YAAY,EAAE;QACjC,IAAIU,OAAO,GAAG,IAAInE,kBAAkB,CAClCmD,MAAM,CAACQ,KAAK,EACZR,MAAM,CAACS,MAAM,EACbT,MAAM,CAACU,IAAI,EACXV,MAAM,CAACW,SAAS,EAChBX,MAAM,CAACM,IAAI,EACXN,MAAM,CAACc,UACT,CAAC;QAED,IAAInB,QAAQ,KAAKC,SAAS,EAAE;UAC1B,IAAII,MAAM,EAAEQ,KAAK,KAAKb,QAAQ,CAACF,QAAQ,CAAC,CAAC,EAAE;YACzChB,QAAQ,CAACuC,OAAO,CAAC;UACnB;UACA;QACF;QAEA,IAAIrB,QAAQ,KAAKC,SAAS,EAAE;UAC1B,IAAII,MAAM,EAAEQ,KAAK,KAAKb,QAAQ,CAACF,QAAQ,CAAC,CAAC,EAAE;YACzC;cACE,IAAI,CAACJ,yBAAyB,CAACtC,GAAG,CAACQ,gBAAgB,EAAEyD,OAAO,EAAErB,QAAQ,CAACF,QAAQ,CAAC,CAAC,CAAC;YACpF;YACA;UACF;QACF;QAEA,IAAI,CAACN,eAAe,CAACpC,GAAG,CAACI,SAAS,EAAE6D,OAAO,CAAC;QAC5C;MACF;MAEA,IAAIhB,MAAM,EAAEM,IAAI,KAAK,SAAS,EAAE;QAC9B,IAAIC,YAAY,GAAG,IAAI3D,eAAe,CACpCoD,MAAM,CAACQ,KAAK,EACZR,MAAM,CAACS,MAAM,EACbT,MAAM,CAACU,IAAI,EACXV,MAAM,CAACW,SAAS,EAChBX,MAAM,CAACM,IAAI,EACXN,MAAM,CAACY,MAAM,EACbZ,MAAM,CAACa,IAAI,EACXb,MAAM,CAACc,UACT,CAAC;QAED,IAAInB,QAAQ,KAAKC,SAAS,EAAE;UAC1B,IAAII,MAAM,EAAEQ,KAAK,KAAKb,QAAQ,CAACF,QAAQ,CAAC,CAAC,EAAE;YACzC,IAAI,CAACJ,yBAAyB,CAACtC,GAAG,CAACQ,gBAAgB,EAAEgD,YAAY,EAAEZ,QAAQ,CAACF,QAAQ,CAAC,CAAC,CAAC;UACzF;UACA;QACF;QAEA,IAAI,CAACN,eAAe,CAACpC,GAAG,CAACI,SAAS,EAAEoD,YAAY,CAAC;QACjD;MACF;MAEA,IAAIP,MAAM,KAAKJ,SAAS,IAAI,CAAC,CAAC,SAAS,EAAE,YAAY,CAAC,CAACwB,QAAQ,CAACpB,MAAM,EAAEM,IAAI,CAAC,EAAE;QAC7E,IAAIe,YAAY,GAAG,IAAIvE,eAAe,CACpCkD,MAAM,CAACQ,KAAK,EACZR,MAAM,CAACS,MAAM,EACbT,MAAM,CAACU,IAAI,EACXV,MAAM,CAACW,SAAS,EAChBX,MAAM,CAACM,IAAI,EACXN,MAAM,CAACc,UACT,CAAC;QAED,IAAInB,QAAQ,KAAKC,SAAS,EAAE;UAC1B,IAAII,MAAM,EAAEQ,KAAK,KAAKb,QAAQ,CAACF,QAAQ,CAAC,CAAC,EAAE;YACzC;cACE,IAAI,CAACJ,yBAAyB,CAACtC,GAAG,CAACQ,gBAAgB,EAAE8D,YAAY,EAAE1B,QAAQ,CAACF,QAAQ,CAAC,CAAC,CAAC;YACzF;YACA;UACF;QACF;QAEA,IAAI,CAACN,eAAe,CAACpC,GAAG,CAACI,SAAS,EAAEkE,YAAY,CAAC;QACjD;MACF;IACF,CAAC,CAAC;IAEF,OAAO3C,EAAE;EACX;;EAEA;AACF;AACA;AACA;EACE,MAAM4C,KAAKA,CAAA,EAAG;IACZ,IACE,IAAI,CAACtD,mBAAmB,KAAK,IAAI,IACjC,IAAI,CAACA,mBAAmB,KAAK4B,SAAS,IACtC,IAAI,CAAC5B,mBAAmB,CAACuD,MAAM,GAAG,CAAC,EACnC;MACA,MAAM,IAAI,CAAC9D,IAAI,CAAC+D,WAAW,CAAC,gBAAgB,EAAE,IAAI,CAACxD,mBAAmB,CAAC;IACzE,CAAC,MAAM;MACL,MAAM,IAAI,CAACP,IAAI,CAAC+D,WAAW,CAAC,gBAAgB,CAAC;IAC/C;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeC,uBAAuBA,CAAC5D,MAAM,EAAEC,kBAAkB,EAAE;EACjE,IAAI4D,QAAQ,GAAG,IAAIlE,YAAY,CAACK,MAAM,EAAEC,kBAAkB,CAAC;EAC3D,MAAM4D,QAAQ,CAACtD,IAAI,CAAC,CAAC;EACrB,OAAOsD,QAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAGH,uBAAuB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}