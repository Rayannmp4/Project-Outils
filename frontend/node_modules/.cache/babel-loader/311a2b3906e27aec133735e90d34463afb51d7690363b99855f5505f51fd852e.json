{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst {\n  BeforeRequestSent,\n  ResponseStarted,\n  FetchError\n} = require('./networkTypes');\nconst {\n  AddInterceptParameters\n} = require('./addInterceptParameters');\nconst {\n  ContinueResponseParameters\n} = require('./continueResponseParameters');\nconst {\n  ContinueRequestParameters\n} = require('./continueRequestParameters');\nconst {\n  ProvideResponseParameters\n} = require('./provideResponseParameters');\nconst NetworkEvent = {\n  BEFORE_REQUEST_SENT: 'network.beforeRequestSent',\n  RESPONSE_STARTED: 'network.responseStarted',\n  RESPONSE_COMPLETED: 'network.responseCompleted',\n  AUTH_REQUIRED: 'network.authRequired',\n  FETCH_ERROR: 'network.fetchError'\n};\nconst CacheBehavior = Object.freeze({\n  DEFAULT: 'default',\n  BYPASS: 'bypass'\n});\n\n/**\n * Represents all commands and events of Network module.\n * Described in https://w3c.github.io/webdriver-bidi/#module-network.\n */\nclass Network {\n  #callbackId = 0;\n  #listener;\n\n  /**\n   * Represents a Network object.\n   * @constructor\n   * @param {Driver} driver - The driver to fetch the BiDi connection.\n   * @param {Array} browsingContextIds - An array of browsing context IDs that the network events will be subscribed to.\n   */\n  constructor(driver, browsingContextIds) {\n    this._driver = driver;\n    this._browsingContextIds = browsingContextIds;\n    this.#listener = new Map();\n    this.#listener.set(NetworkEvent.AUTH_REQUIRED, new Map());\n    this.#listener.set(NetworkEvent.BEFORE_REQUEST_SENT, new Map());\n    this.#listener.set(NetworkEvent.FETCH_ERROR, new Map());\n    this.#listener.set(NetworkEvent.RESPONSE_STARTED, new Map());\n    this.#listener.set(NetworkEvent.RESPONSE_COMPLETED, new Map());\n  }\n  addCallback(eventType, callback) {\n    const id = ++this.#callbackId;\n    const eventCallbackMap = this.#listener.get(eventType);\n    eventCallbackMap.set(id, callback);\n    return id;\n  }\n  removeCallback(id) {\n    let hasId = false;\n    for (const [, callbacks] of this.#listener) {\n      if (callbacks.has(id)) {\n        callbacks.delete(id);\n        hasId = true;\n      }\n    }\n    if (!hasId) {\n      throw Error(`Callback with id ${id} not found`);\n    }\n  }\n  invokeCallbacks(eventType, data) {\n    const callbacks = this.#listener.get(eventType);\n    if (callbacks) {\n      for (const [, callback] of callbacks) {\n        callback(data);\n      }\n    }\n  }\n  async init() {\n    this.bidi = await this._driver.getBidi();\n  }\n\n  /**\n   * Subscribes to the 'network.beforeRequestSent' event and handles it with the provided callback.\n   *\n   * @param {Function} callback - The callback function to handle the event.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async beforeRequestSent(callback) {\n    await this.subscribeAndHandleEvent('network.beforeRequestSent', callback);\n  }\n\n  /**\n   * Subscribes to the 'network.responseStarted' event and handles it with the provided callback.\n   *\n   * @param {Function} callback - The callback function to handle the event.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async responseStarted(callback) {\n    await this.subscribeAndHandleEvent('network.responseStarted', callback);\n  }\n\n  /**\n   * Subscribes to the 'network.responseCompleted' event and handles it with the provided callback.\n   *\n   * @param {Function} callback - The callback function to handle the event.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async responseCompleted(callback) {\n    await this.subscribeAndHandleEvent('network.responseCompleted', callback);\n  }\n\n  /**\n   * Subscribes to the 'network.authRequired' event and handles it with the provided callback.\n   *\n   * @param {Function} callback - The callback function to handle the event.\n   * @returns {Promise<number>} - A promise that resolves when the subscription is successful.\n   */\n  async authRequired(callback) {\n    return await this.subscribeAndHandleEvent('network.authRequired', callback);\n  }\n\n  /**\n   * Subscribes to the 'network.fetchError' event and handles it with the provided callback.\n   *\n   * @param {Function} callback - The callback function to handle the event.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async fetchError(callback) {\n    await this.subscribeAndHandleEvent('network.fetchError', callback);\n  }\n  async subscribeAndHandleEvent(eventType, callback) {\n    if (this._browsingContextIds != null) {\n      await this.bidi.subscribe(eventType, this._browsingContextIds);\n    } else {\n      await this.bidi.subscribe(eventType);\n    }\n    let id = this.addCallback(eventType, callback);\n    this.ws = await this.bidi.socket;\n    this.ws.on('message', event => {\n      const {\n        params\n      } = JSON.parse(Buffer.from(event.toString()));\n      if (params) {\n        let response = null;\n        if ('initiator' in params) {\n          response = new BeforeRequestSent(params.context, params.navigation, params.redirectCount, params.request, params.timestamp, params.initiator);\n        } else if ('response' in params) {\n          response = new ResponseStarted(params.context, params.navigation, params.redirectCount, params.request, params.timestamp, params.response);\n        } else if ('errorText' in params) {\n          response = new FetchError(params.context, params.navigation, params.redirectCount, params.request, params.timestamp, params.errorText);\n        }\n        this.invokeCallbacks(eventType, response);\n      }\n    });\n    return id;\n  }\n\n  /**\n   * Adds a network intercept.\n   *\n   * @param {AddInterceptParameters} params - The parameters for the network intercept.\n   * @returns {Promise<string>} - A promise that resolves to the added intercept's id.\n   * @throws {Error} - If params is not an instance of AddInterceptParameters.\n   */\n  async addIntercept(params) {\n    if (!(params instanceof AddInterceptParameters)) {\n      throw new Error(`Params must be an instance of AddInterceptParameters. Received:'${params}'`);\n    }\n    const command = {\n      method: 'network.addIntercept',\n      params: Object.fromEntries(params.asMap())\n    };\n    let response = await this.bidi.send(command);\n    return response.result.intercept;\n  }\n\n  /**\n   * Removes an intercept.\n   *\n   * @param {string} interceptId - The ID of the intercept to be removed.\n   * @returns {Promise<void>} - A promise that resolves when the intercept is successfully removed.\n   */\n  async removeIntercept(interceptId) {\n    const command = {\n      method: 'network.removeIntercept',\n      params: {\n        intercept: interceptId\n      }\n    };\n    await this.bidi.send(command);\n  }\n\n  /**\n   * Continues the network request with authentication credentials.\n   * @param {string} requestId - The ID of the request to continue.\n   * @param {string} username - The username for authentication.\n   * @param {string} password - The password for authentication.\n   * @returns {Promise<void>} - A promise that resolves when the command is sent.\n   */\n  async continueWithAuth(requestId, username, password) {\n    const command = {\n      method: 'network.continueWithAuth',\n      params: {\n        request: requestId.toString(),\n        action: 'provideCredentials',\n        credentials: {\n          type: 'password',\n          username: username,\n          password: password\n        }\n      }\n    };\n    await this.bidi.send(command);\n  }\n\n  /**\n   * Fails a network request.\n   *\n   * @param {number} requestId - The ID of the request to fail.\n   * @returns {Promise<void>} - A promise that resolves when the command is sent.\n   */\n  async failRequest(requestId) {\n    const command = {\n      method: 'network.failRequest',\n      params: {\n        request: requestId.toString()\n      }\n    };\n    await this.bidi.send(command);\n  }\n\n  /**\n   * Continues the network request with authentication but without providing credentials.\n   * @param {string} requestId - The ID of the request to continue with authentication.\n   * @returns {Promise<void>} - A promise that resolves when the command is sent.\n   */\n  async continueWithAuthNoCredentials(requestId) {\n    const command = {\n      method: 'network.continueWithAuth',\n      params: {\n        request: requestId.toString(),\n        action: 'default'\n      }\n    };\n    await this.bidi.send(command);\n  }\n\n  /**\n   * Cancels the authentication for a specific request.\n   *\n   * @param {string} requestId - The ID of the request to cancel authentication for.\n   * @returns {Promise<void>} - A promise that resolves when the command is sent.\n   */\n  async cancelAuth(requestId) {\n    const command = {\n      method: 'network.continueWithAuth',\n      params: {\n        request: requestId.toString(),\n        action: 'cancel'\n      }\n    };\n    await this.bidi.send(command);\n  }\n\n  /**\n   * Continues the network request with the provided parameters.\n   *\n   * @param {ContinueRequestParameters} params - The parameters for continuing the request.\n   * @throws {Error} If params is not an instance of ContinueRequestParameters.\n   * @returns {Promise<void>} A promise that resolves when the command is sent.\n   */\n  async continueRequest(params) {\n    if (!(params instanceof ContinueRequestParameters)) {\n      throw new Error(`Params must be an instance of ContinueRequestParameters. Received:'${params}'`);\n    }\n    const command = {\n      method: 'network.continueRequest',\n      params: Object.fromEntries(params.asMap())\n    };\n    await this.bidi.send(command);\n  }\n\n  /**\n   * Continues the network response with the given parameters.\n   *\n   * @param {ContinueResponseParameters} params - The parameters for continuing the response.\n   * @throws {Error} If params is not an instance of ContinueResponseParameters.\n   * @returns {Promise<void>} A promise that resolves when the command is sent.\n   */\n  async continueResponse(params) {\n    if (!(params instanceof ContinueResponseParameters)) {\n      throw new Error(`Params must be an instance of ContinueResponseParameters. Received:'${params}'`);\n    }\n    const command = {\n      method: 'network.continueResponse',\n      params: Object.fromEntries(params.asMap())\n    };\n    await this.bidi.send(command);\n  }\n\n  /**\n   * Provides a response for the network.\n   *\n   * @param {ProvideResponseParameters} params - The parameters for providing the response.\n   * @throws {Error} If params is not an instance of ProvideResponseParameters.\n   * @returns {Promise<void>} A promise that resolves when the command is sent.\n   */\n  async provideResponse(params) {\n    if (!(params instanceof ProvideResponseParameters)) {\n      throw new Error(`Params must be an instance of ProvideResponseParameters. Received:'${params}'`);\n    }\n    const command = {\n      method: 'network.provideResponse',\n      params: Object.fromEntries(params.asMap())\n    };\n    await this.bidi.send(command);\n  }\n\n  /**\n   * Sets the cache behavior for network requests.\n   *\n   * @param {string} behavior - The cache behavior (\"default\" or \"bypass\")\n   * @param {Array<string>} [contexts] - Optional array of browsing context IDs\n   * @returns {Promise<void>} A promise that resolves when the cache behavior is set\n   * @throws {Error} If behavior is invalid or context IDs are invalid\n   */\n  async setCacheBehavior(behavior, contexts = null) {\n    if (!Object.values(CacheBehavior).includes(behavior)) {\n      throw new Error(`Cache behavior must be either \"${CacheBehavior.DEFAULT}\" or \"${CacheBehavior.BYPASS}\"`);\n    }\n    const command = {\n      method: 'network.setCacheBehavior',\n      params: {\n        cacheBehavior: behavior\n      }\n    };\n    if (contexts !== null) {\n      if (!Array.isArray(contexts) || contexts.length === 0 || contexts.some(c => typeof c !== 'string' || c.trim() === '')) {\n        throw new Error('Contexts must be an array of non-empty strings');\n      }\n      command.params.contexts = contexts;\n    }\n    await this.bidi.send(command);\n  }\n\n  /**\n   * Unsubscribes from network events for all browsing contexts.\n   * @returns {Promise<void>} A promise that resolves when the network connection is closed.\n   */\n  async close() {\n    if (this._browsingContextIds !== null && this._browsingContextIds !== undefined && this._browsingContextIds.length > 0) {\n      await this.bidi.unsubscribe('network.beforeRequestSent', 'network.responseStarted', 'network.responseCompleted', 'network.authRequired', this._browsingContextIds);\n    } else {\n      await this.bidi.unsubscribe('network.beforeRequestSent', 'network.responseStarted', 'network.responseCompleted', 'network.authRequired');\n    }\n  }\n}\nasync function getNetworkInstance(driver, browsingContextIds = null) {\n  let instance = new Network(driver, browsingContextIds);\n  await instance.init();\n  return instance;\n}\nmodule.exports = {\n  Network: getNetworkInstance,\n  CacheBehavior\n};","map":{"version":3,"names":["BeforeRequestSent","ResponseStarted","FetchError","require","AddInterceptParameters","ContinueResponseParameters","ContinueRequestParameters","ProvideResponseParameters","NetworkEvent","BEFORE_REQUEST_SENT","RESPONSE_STARTED","RESPONSE_COMPLETED","AUTH_REQUIRED","FETCH_ERROR","CacheBehavior","Object","freeze","DEFAULT","BYPASS","Network","callbackId","listener","constructor","driver","browsingContextIds","_driver","_browsingContextIds","Map","set","addCallback","eventType","callback","id","eventCallbackMap","get","removeCallback","hasId","callbacks","has","delete","Error","invokeCallbacks","data","init","bidi","getBidi","beforeRequestSent","subscribeAndHandleEvent","responseStarted","responseCompleted","authRequired","fetchError","subscribe","ws","socket","on","event","params","JSON","parse","Buffer","from","toString","response","context","navigation","redirectCount","request","timestamp","initiator","errorText","addIntercept","command","method","fromEntries","asMap","send","result","intercept","removeIntercept","interceptId","continueWithAuth","requestId","username","password","action","credentials","type","failRequest","continueWithAuthNoCredentials","cancelAuth","continueRequest","continueResponse","provideResponse","setCacheBehavior","behavior","contexts","values","includes","cacheBehavior","Array","isArray","length","some","c","trim","close","undefined","unsubscribe","getNetworkInstance","instance","module","exports"],"sources":["C:/Users/rayan/Documents/GitHub/Project-Outils/node_modules/selenium-webdriver/bidi/network.js"],"sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nconst { BeforeRequestSent, ResponseStarted, FetchError } = require('./networkTypes')\nconst { AddInterceptParameters } = require('./addInterceptParameters')\nconst { ContinueResponseParameters } = require('./continueResponseParameters')\nconst { ContinueRequestParameters } = require('./continueRequestParameters')\nconst { ProvideResponseParameters } = require('./provideResponseParameters')\n\nconst NetworkEvent = {\n  BEFORE_REQUEST_SENT: 'network.beforeRequestSent',\n  RESPONSE_STARTED: 'network.responseStarted',\n  RESPONSE_COMPLETED: 'network.responseCompleted',\n  AUTH_REQUIRED: 'network.authRequired',\n  FETCH_ERROR: 'network.fetchError',\n}\n\nconst CacheBehavior = Object.freeze({\n  DEFAULT: 'default',\n  BYPASS: 'bypass',\n})\n\n/**\n * Represents all commands and events of Network module.\n * Described in https://w3c.github.io/webdriver-bidi/#module-network.\n */\nclass Network {\n  #callbackId = 0\n  #listener\n\n  /**\n   * Represents a Network object.\n   * @constructor\n   * @param {Driver} driver - The driver to fetch the BiDi connection.\n   * @param {Array} browsingContextIds - An array of browsing context IDs that the network events will be subscribed to.\n   */\n  constructor(driver, browsingContextIds) {\n    this._driver = driver\n    this._browsingContextIds = browsingContextIds\n    this.#listener = new Map()\n    this.#listener.set(NetworkEvent.AUTH_REQUIRED, new Map())\n    this.#listener.set(NetworkEvent.BEFORE_REQUEST_SENT, new Map())\n    this.#listener.set(NetworkEvent.FETCH_ERROR, new Map())\n    this.#listener.set(NetworkEvent.RESPONSE_STARTED, new Map())\n    this.#listener.set(NetworkEvent.RESPONSE_COMPLETED, new Map())\n  }\n\n  addCallback(eventType, callback) {\n    const id = ++this.#callbackId\n\n    const eventCallbackMap = this.#listener.get(eventType)\n    eventCallbackMap.set(id, callback)\n    return id\n  }\n\n  removeCallback(id) {\n    let hasId = false\n    for (const [, callbacks] of this.#listener) {\n      if (callbacks.has(id)) {\n        callbacks.delete(id)\n        hasId = true\n      }\n    }\n\n    if (!hasId) {\n      throw Error(`Callback with id ${id} not found`)\n    }\n  }\n\n  invokeCallbacks(eventType, data) {\n    const callbacks = this.#listener.get(eventType)\n    if (callbacks) {\n      for (const [, callback] of callbacks) {\n        callback(data)\n      }\n    }\n  }\n\n  async init() {\n    this.bidi = await this._driver.getBidi()\n  }\n\n  /**\n   * Subscribes to the 'network.beforeRequestSent' event and handles it with the provided callback.\n   *\n   * @param {Function} callback - The callback function to handle the event.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async beforeRequestSent(callback) {\n    await this.subscribeAndHandleEvent('network.beforeRequestSent', callback)\n  }\n\n  /**\n   * Subscribes to the 'network.responseStarted' event and handles it with the provided callback.\n   *\n   * @param {Function} callback - The callback function to handle the event.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async responseStarted(callback) {\n    await this.subscribeAndHandleEvent('network.responseStarted', callback)\n  }\n\n  /**\n   * Subscribes to the 'network.responseCompleted' event and handles it with the provided callback.\n   *\n   * @param {Function} callback - The callback function to handle the event.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async responseCompleted(callback) {\n    await this.subscribeAndHandleEvent('network.responseCompleted', callback)\n  }\n\n  /**\n   * Subscribes to the 'network.authRequired' event and handles it with the provided callback.\n   *\n   * @param {Function} callback - The callback function to handle the event.\n   * @returns {Promise<number>} - A promise that resolves when the subscription is successful.\n   */\n  async authRequired(callback) {\n    return await this.subscribeAndHandleEvent('network.authRequired', callback)\n  }\n\n  /**\n   * Subscribes to the 'network.fetchError' event and handles it with the provided callback.\n   *\n   * @param {Function} callback - The callback function to handle the event.\n   * @returns {Promise<void>} - A promise that resolves when the subscription is successful.\n   */\n  async fetchError(callback) {\n    await this.subscribeAndHandleEvent('network.fetchError', callback)\n  }\n\n  async subscribeAndHandleEvent(eventType, callback) {\n    if (this._browsingContextIds != null) {\n      await this.bidi.subscribe(eventType, this._browsingContextIds)\n    } else {\n      await this.bidi.subscribe(eventType)\n    }\n    let id = this.addCallback(eventType, callback)\n\n    this.ws = await this.bidi.socket\n    this.ws.on('message', (event) => {\n      const { params } = JSON.parse(Buffer.from(event.toString()))\n      if (params) {\n        let response = null\n        if ('initiator' in params) {\n          response = new BeforeRequestSent(\n            params.context,\n            params.navigation,\n            params.redirectCount,\n            params.request,\n            params.timestamp,\n            params.initiator,\n          )\n        } else if ('response' in params) {\n          response = new ResponseStarted(\n            params.context,\n            params.navigation,\n            params.redirectCount,\n            params.request,\n            params.timestamp,\n            params.response,\n          )\n        } else if ('errorText' in params) {\n          response = new FetchError(\n            params.context,\n            params.navigation,\n            params.redirectCount,\n            params.request,\n            params.timestamp,\n            params.errorText,\n          )\n        }\n        this.invokeCallbacks(eventType, response)\n      }\n    })\n    return id\n  }\n\n  /**\n   * Adds a network intercept.\n   *\n   * @param {AddInterceptParameters} params - The parameters for the network intercept.\n   * @returns {Promise<string>} - A promise that resolves to the added intercept's id.\n   * @throws {Error} - If params is not an instance of AddInterceptParameters.\n   */\n  async addIntercept(params) {\n    if (!(params instanceof AddInterceptParameters)) {\n      throw new Error(`Params must be an instance of AddInterceptParameters. Received:'${params}'`)\n    }\n\n    const command = {\n      method: 'network.addIntercept',\n      params: Object.fromEntries(params.asMap()),\n    }\n\n    let response = await this.bidi.send(command)\n\n    return response.result.intercept\n  }\n\n  /**\n   * Removes an intercept.\n   *\n   * @param {string} interceptId - The ID of the intercept to be removed.\n   * @returns {Promise<void>} - A promise that resolves when the intercept is successfully removed.\n   */\n  async removeIntercept(interceptId) {\n    const command = {\n      method: 'network.removeIntercept',\n      params: { intercept: interceptId },\n    }\n\n    await this.bidi.send(command)\n  }\n\n  /**\n   * Continues the network request with authentication credentials.\n   * @param {string} requestId - The ID of the request to continue.\n   * @param {string} username - The username for authentication.\n   * @param {string} password - The password for authentication.\n   * @returns {Promise<void>} - A promise that resolves when the command is sent.\n   */\n  async continueWithAuth(requestId, username, password) {\n    const command = {\n      method: 'network.continueWithAuth',\n      params: {\n        request: requestId.toString(),\n        action: 'provideCredentials',\n        credentials: {\n          type: 'password',\n          username: username,\n          password: password,\n        },\n      },\n    }\n    await this.bidi.send(command)\n  }\n\n  /**\n   * Fails a network request.\n   *\n   * @param {number} requestId - The ID of the request to fail.\n   * @returns {Promise<void>} - A promise that resolves when the command is sent.\n   */\n  async failRequest(requestId) {\n    const command = {\n      method: 'network.failRequest',\n      params: {\n        request: requestId.toString(),\n      },\n    }\n    await this.bidi.send(command)\n  }\n\n  /**\n   * Continues the network request with authentication but without providing credentials.\n   * @param {string} requestId - The ID of the request to continue with authentication.\n   * @returns {Promise<void>} - A promise that resolves when the command is sent.\n   */\n  async continueWithAuthNoCredentials(requestId) {\n    const command = {\n      method: 'network.continueWithAuth',\n      params: {\n        request: requestId.toString(),\n        action: 'default',\n      },\n    }\n    await this.bidi.send(command)\n  }\n\n  /**\n   * Cancels the authentication for a specific request.\n   *\n   * @param {string} requestId - The ID of the request to cancel authentication for.\n   * @returns {Promise<void>} - A promise that resolves when the command is sent.\n   */\n  async cancelAuth(requestId) {\n    const command = {\n      method: 'network.continueWithAuth',\n      params: {\n        request: requestId.toString(),\n        action: 'cancel',\n      },\n    }\n    await this.bidi.send(command)\n  }\n\n  /**\n   * Continues the network request with the provided parameters.\n   *\n   * @param {ContinueRequestParameters} params - The parameters for continuing the request.\n   * @throws {Error} If params is not an instance of ContinueRequestParameters.\n   * @returns {Promise<void>} A promise that resolves when the command is sent.\n   */\n  async continueRequest(params) {\n    if (!(params instanceof ContinueRequestParameters)) {\n      throw new Error(`Params must be an instance of ContinueRequestParameters. Received:'${params}'`)\n    }\n\n    const command = {\n      method: 'network.continueRequest',\n      params: Object.fromEntries(params.asMap()),\n    }\n\n    await this.bidi.send(command)\n  }\n\n  /**\n   * Continues the network response with the given parameters.\n   *\n   * @param {ContinueResponseParameters} params - The parameters for continuing the response.\n   * @throws {Error} If params is not an instance of ContinueResponseParameters.\n   * @returns {Promise<void>} A promise that resolves when the command is sent.\n   */\n  async continueResponse(params) {\n    if (!(params instanceof ContinueResponseParameters)) {\n      throw new Error(`Params must be an instance of ContinueResponseParameters. Received:'${params}'`)\n    }\n\n    const command = {\n      method: 'network.continueResponse',\n      params: Object.fromEntries(params.asMap()),\n    }\n\n    await this.bidi.send(command)\n  }\n\n  /**\n   * Provides a response for the network.\n   *\n   * @param {ProvideResponseParameters} params - The parameters for providing the response.\n   * @throws {Error} If params is not an instance of ProvideResponseParameters.\n   * @returns {Promise<void>} A promise that resolves when the command is sent.\n   */\n  async provideResponse(params) {\n    if (!(params instanceof ProvideResponseParameters)) {\n      throw new Error(`Params must be an instance of ProvideResponseParameters. Received:'${params}'`)\n    }\n\n    const command = {\n      method: 'network.provideResponse',\n      params: Object.fromEntries(params.asMap()),\n    }\n\n    await this.bidi.send(command)\n  }\n\n  /**\n   * Sets the cache behavior for network requests.\n   *\n   * @param {string} behavior - The cache behavior (\"default\" or \"bypass\")\n   * @param {Array<string>} [contexts] - Optional array of browsing context IDs\n   * @returns {Promise<void>} A promise that resolves when the cache behavior is set\n   * @throws {Error} If behavior is invalid or context IDs are invalid\n   */\n  async setCacheBehavior(behavior, contexts = null) {\n    if (!Object.values(CacheBehavior).includes(behavior)) {\n      throw new Error(`Cache behavior must be either \"${CacheBehavior.DEFAULT}\" or \"${CacheBehavior.BYPASS}\"`)\n    }\n\n    const command = {\n      method: 'network.setCacheBehavior',\n      params: {\n        cacheBehavior: behavior,\n      },\n    }\n\n    if (contexts !== null) {\n      if (\n        !Array.isArray(contexts) ||\n        contexts.length === 0 ||\n        contexts.some((c) => typeof c !== 'string' || c.trim() === '')\n      ) {\n        throw new Error('Contexts must be an array of non-empty strings')\n      }\n      command.params.contexts = contexts\n    }\n\n    await this.bidi.send(command)\n  }\n\n  /**\n   * Unsubscribes from network events for all browsing contexts.\n   * @returns {Promise<void>} A promise that resolves when the network connection is closed.\n   */\n  async close() {\n    if (\n      this._browsingContextIds !== null &&\n      this._browsingContextIds !== undefined &&\n      this._browsingContextIds.length > 0\n    ) {\n      await this.bidi.unsubscribe(\n        'network.beforeRequestSent',\n        'network.responseStarted',\n        'network.responseCompleted',\n        'network.authRequired',\n        this._browsingContextIds,\n      )\n    } else {\n      await this.bidi.unsubscribe(\n        'network.beforeRequestSent',\n        'network.responseStarted',\n        'network.responseCompleted',\n        'network.authRequired',\n      )\n    }\n  }\n}\n\nasync function getNetworkInstance(driver, browsingContextIds = null) {\n  let instance = new Network(driver, browsingContextIds)\n  await instance.init()\n  return instance\n}\n\nmodule.exports = { Network: getNetworkInstance, CacheBehavior }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}